<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WangJiaYing</title>
  
  
  <link href="https://cwhisme.ml/atom.xml" rel="self"/>
  
  <link href="https://cwhisme.ml/"/>
  <updated>2021-06-10T06:43:18.822Z</updated>
  <id>https://cwhisme.ml/</id>
  
  <author>
    <name>CWHISME</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于我把博客又从Jekyll换成Hexo这件事</title>
    <link href="https://cwhisme.ml/2021/06/06/%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8A%E5%8D%9A%E5%AE%A2%E5%8F%88%E4%BB%8EJekyll%E6%8D%A2%E6%88%90Hexo%E8%BF%99%E4%BB%B6%E4%BA%8B/"/>
    <id>https://cwhisme.ml/2021/06/06/%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8A%E5%8D%9A%E5%AE%A2%E5%8F%88%E4%BB%8EJekyll%E6%8D%A2%E6%88%90Hexo%E8%BF%99%E4%BB%B6%E4%BA%8B/</id>
    <published>2021-06-06T14:46:11.000Z</published>
    <updated>2021-06-10T06:43:18.822Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2021年6月6日，星期日，天气晴；温度估摸着也有30来度了。</p><p>周五的时候简单地把Jekyll文章挪了过来，各种主题上的自定义及配置的修改都没做，于是今天又改了一波，真实麻烦。</p><p>为啥又这样做呢？起因还是之前偶然又登陆了下Coding，查了下项目发现原来托管到CodingPage上的Hexo博客竟然还在运行，只是访问路径被Coding改得面目全非了，所以之前的地址才没法访问。</p><p>于是点进去看了下，感觉还比现在的Jekyll主题好看。</p><p>而且用了段时间的Jekyll才觉悟到，这引擎有个非常大的问题：网站源文件等等都是完全暴露的！<br>因为托管到Git上的整个项目都是Public，连文章MD文档都是原生展示，这就很危险了。</p><p>前些日子项目又稍微有点忙，也就暂且没管，这两天抽出时间来，换了一波，把Jekyll那边对主题的自定义修改又想着改到Hexo主题这边，比如valine评论之类的。</p><p>本来评论还想换成Waline的，也弄上去试过，但是感觉还得要额外在Vercel托管一个服务端有点麻烦，而且速度也慢了很多，有时候还莫名连不上，所以就暂且放弃了。</p><p>Jekyll用的是这份主题：<a href="https://github.com/DONGChuan/Yummy-Jekyll">Github</a></p><p><img src="/blogimages/2021/2021-06-06-%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8A%E5%8D%9A%E5%AE%A2%E5%8F%88%E4%BB%8EJekyll%E6%8D%A2%E6%88%90Hexo%E8%BF%99%E4%BB%B6%E4%BA%8B-Jekyll.png" alt="Jekyll"></p><p>换成Hexo用的这份主题：<a href="https://github.com/klugjo/hexo-theme-anodyne">Github</a></p><p>同时自定义了一些内容：</p><p><img src="/blogimages/2021/2021-06-06-%E5%85%B3%E4%BA%8E%E6%88%91%E6%8A%8A%E5%8D%9A%E5%AE%A2%E5%8F%88%E4%BB%8EJekyll%E6%8D%A2%E6%88%90Hexo%E8%BF%99%E4%BB%B6%E4%BA%8B-Hexo.png" alt="Jekyll"></p><p>其中在处理JsDeliver加速图片方面开始有点捉鸡，不过后面也解决了。</p><p>主要因为是 Jekyll 使用的模板语言是 Liquid，Hexo是 ejs，所以挪过来在统一替换图片地址方面开始有点找不到方法。<br>不过查了下 ejs 实际上就是用 js 语法，然后就注意找了下文章内容的解析位置，后面定位到 post 模板，在其中 page.content 字段处，使用以下代码进行替换解决的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%- page.content.replaceAll(&quot;blogimages&quot;,(theme.cdn.path==null?&quot;&quot;:theme.cdn.path)+&quot;blogimages&quot;) %&gt;</span><br></pre></td></tr></table></figure><p>后边还增加了点击烟花效果，出处为：<a href="https://codepen.io/juliangarnier/pen/gmOwJX">Anime.js Fireworks canvas demo</a></p><p>是从<a href="https://yun.yunyoujun.cn/guide/config.html#%E7%83%9F%E8%8A%B1">云游君</a>的Hexo主题介绍处看过来的，因为开始其实还想用用那个主题来着。</p><hr><p>最后，我摊牌：其实Jakyll也是可以直接上传本地编译后静态内容上去的，虽然部分语法就不能使用了，不过也可以实现这种 “非公共的项目存储源文件”，仅发布编译后内容的。</p><p>我就是馋原来这个Hexo主题 ╮(￣▽￣)╭</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天是2021年6月6日，星期日，天气晴；温度估摸着也有30来度了。&lt;/p&gt;
&lt;p&gt;周五的时候简单地把Jekyll文章挪了过来，各种主题上的自定义及配置的修改都没做，于是今天又改了一波，真实麻烦。&lt;/p&gt;
&lt;p&gt;为啥又这样做呢？起因还是之前偶然又登陆了下Coding，查了下</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ado.Net与EF6.X的简单使用</title>
    <link href="https://cwhisme.ml/2021/04/28/Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://cwhisme.ml/2021/04/28/Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-28T03:21:00.000Z</published>
    <updated>2021-06-10T10:06:33.288Z</updated>
    
    <content type="html"><![CDATA[<p>ADO.NET是微软提供的一种对数据库方便操作的功能，实体框架EF6(Entity Framework 6) 应当属于其中子集。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下为微软官方的介绍：</p><h4 id="ADO-NET"><a href="#ADO-NET" class="headerlink" title="ADO.NET"></a>ADO.NET</h4><blockquote><p>ADO.NET 是一组向 .NET Framework 程序员公开数据访问服务的类。 ADO.NET 为创建分布式数据共享应用程序提供了一组丰富的组件。 它提供了对关系数据、XML 和应用程序数据的访问，因此是 .NET Framework 中不可缺少的一部分。 ADO.NET 支持多种开发需求，包括创建由应用程序、工具、语言或 Internet 浏览器使用的前端数据库客户端和中间层业务对象。</p></blockquote><h4 id="Entity-Framework-6"><a href="#Entity-Framework-6" class="headerlink" title="Entity Framework 6"></a>Entity Framework 6</h4><blockquote><p>实体框架 6 (EF6) 是经试验和测试的关系映射器 (O/RM)，适用于 .NET 的对象，其功能和稳定性经过了多年的开发和调试。</p></blockquote><p><em>注：同类还包括EF Core，根据官方文档，似乎相比EF6，更推荐EF Core。</em></p><p>目前这篇文章，之所以写这个流程，主要是昨天一个网友发给我一个网友做的游戏开源项目，那是一个网络类游戏Demo，数据库使用的SQLserver，就用到了这个模型。<br>抱着学习学习的心态，于是看了下代码，并且想跑跑看，于是运行了起来，不过在执行到新建账号那些操作数据相关内容的时候就一直报错。</p><p>当时一开始根本没看到哪里有具体操作数据库的，只看到使用linq直接直接读取列表，改完SaveChanges就算存储了？</p><p>大概就像这种代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TUser user = DBService.Instance.Entities.Users.Where(u =&gt; u.Username == request.User).FirstOrDefault();</span><br><span class="line"><span class="keyword">if</span>(user==<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    DBService.Instance.Entities.Users.Add(<span class="keyword">new</span> TUser()</span><br><span class="line">    &#123;</span><br><span class="line">        Player = <span class="keyword">new</span> TPlayer(),</span><br><span class="line">        Username = request.User,</span><br><span class="line">        Password = request.Passward</span><br><span class="line">    &#125;);</span><br><span class="line">    DBService.Instance.Entities.SaveChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>注：DBService是个单例，单纯缓存了Entities的实例而已，几乎没有任何其他什么代码。</em></p><p>数据库操作有这么简单？不要唬我，就感觉一脸懵逼。后边才明白过来，感情是用了框架，所以都被封装简化了。</p><p>项目最近难得没有忙天忙地，自己有空在研究网络这块，还想自己搞个游戏的网络框架玩玩，这么简单的数据库操作方式，不拿来用用怎么行？</p><p>于是又研究了下相关使用，查了下官方文档，研究了一番跑了起来——虽然最终发现Demo就不完整，运行出来依然有缺失。<br>不过至少这种数据库的使用方式算是Get到了，后面可以考虑用起来，先在此记录一下。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>运行上述网友Demo就不提了，这里说的使用指的从头开始创建，然后简单测试使用的流程。</p><ul><li>Model First模型：直接使用设计器设计数据库关系图，生成代码使用。</li><li>Code First模型：代码描述实体对象，数据关系等，然后根据已有的代码描述，自动创建数据对象。</li></ul><p><em>注：本文的流程基于使用 ModelFirst 模型，对CodeFirst模型又兴趣的的可以看官方文档<a href="https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/workflows/new-database">教程</a></em></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>首先，打开Visual Studio，创建一个控制台项目：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_1.png" alt="创建项目"></p><p>个人使用的VS2019。</p><p>这里将项目命名为 AdoNetProject：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_2.png" alt="创建项目"></p><h3 id="创建Ado-Net实体数据模型"><a href="#创建Ado-Net实体数据模型" class="headerlink" title="创建Ado.Net实体数据模型"></a>创建Ado.Net实体数据模型</h3><p>项目创建完成后，首先在根目录新建一个 DataSources 目录，当然命名什么都看自己，都是自定义。</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_3.png" alt="创建目录"></p><p>之所以新建文件夹，主要是后续生成代码会在Ado.Net实体数据模型的同一个目录，如果就直接放在根目录下的话，就会凭空多出很多生成后的『.cs』文件。<br>虽然在VS项目中会被整理到.edmx下，不过在实际目录中，是与其同级存在的。这里避免根目录出现太多散代码文件，最好归档。</p><p>接着右键新建的目录，添加-&gt;新建项，选择 ADO.NET 实体数据类型，这里个人将其命名为 EntityModel</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_4.png" alt="创建目录"></p><p>在开启模型向导界面选择 空EF设计器模型。</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_5.png" alt="创建目录"></p><p><em>注：Code First 模型根据介绍，用于基于代码的映射，这里因为写设计器模型，就不提了。</em></p><p>创建完毕后，在VS中继续双击文件可以打开编辑界面。</p><h3 id="添加测试实体"><a href="#添加测试实体" class="headerlink" title="添加测试实体"></a>添加测试实体</h3><p>在空白处右键， 新增-&gt;实体：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_6.png" alt="创建实体"></p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_7.png" alt="创建实体"></p><p>这里个人命名为TUser，并增加了 UserName 字段。</p><h3 id="添加EF代码自动生成"><a href="#添加EF代码自动生成" class="headerlink" title="添加EF代码自动生成"></a>添加EF代码自动生成</h3><p>创完毕后，继续右键 『添加代码生成项』，使其可以自动生成模型相关代码，选择EF6.X DbContext生成器</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_8.png" alt="生成代码"></p><p>这时，代码就会根据上面创建的实体自动生成了，VS自动刷新后，就可以在创建的edmx文件下看到了。<br>后续当设计器上发送修改，并保存后，代码也会自动同步更新。</p><p>此时已经可以写代码了，不过使用的话，还差最后一步——也就是创建数据库连接。</p><h3 id="生成数据库"><a href="#生成数据库" class="headerlink" title="生成数据库"></a>生成数据库</h3><p>继续在生成器空白处点击右键，选择 『根据模型生成数据库』，在弹出页面选择新建连接：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_9.png" alt="生成代码"></p><p>然后在数据源中选择SQLServer数据库文件，确认进入下一页。<br><em>这里之所以如此选择，是因为个人并未单独安装Sql数据库，如果有安装独立数据库，则也可以选择另外的方式</em></p><p>数据库文件名 选项中点击浏览，并选择一个保存数据库文件的位置(如果有对应的老数据库就可以直接选择老数据库了，前提是两者配得起来)<br>如果是新建数据库，那么可以起一个名字。如图所述，这里命名为 AdoNetProjectData</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_10.png" alt="生成代码"></p><p>点击确定，如果是不存在的数据库文件，则会提示是否新建，确定即可。</p><p>点击下一步，会自动生成一堆用于初始化数据库的SQL代码并预览。</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_11.png" alt="生成代码"></p><p>一般情况下，直接点击完成。<br>这时如果勾选了上一步的保存连接字符串(默认勾选)，数据库连接字符串就会被保存在 App.config 的connectionStrings中。</p><h3 id="执行数据库初始化"><a href="#执行数据库初始化" class="headerlink" title="执行数据库初始化"></a>执行数据库初始化</h3><p>接下来，是连接数据库，并执行上一步所生成的SQL代码。</p><p>此时有两种方式可以实现：</p><h4 id="1-复制SQL代码执行"><a href="#1-复制SQL代码执行" class="headerlink" title="1. 复制SQL代码执行"></a>1. 复制SQL代码执行</h4><p>点击菜单栏的 工具-&gt;连接数据库</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_12.png" alt="连接数据库"></p><p>数据库文件名选择上述步骤所建立的文件，点击测试连接，应当会显示连接成功的提示：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_13.png" alt="连接数据库"></p><p>点击确定即连接成功。</p><p>右键连接成功的数据库，选择『新建查询』，然后将之前自动生成的SQL代码复制进取，点击运行。</p><h4 id="2-直接执行SQL代码"><a href="#2-直接执行SQL代码" class="headerlink" title="2.直接执行SQL代码"></a>2.直接执行SQL代码</h4><p>打开自动生成的SQL代码，可以发现左上角有个三角形运行符号，点击后连接，然后将旁边的目标选择为上述添加的数据库文件路径，再点击运行。</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_14.png" alt="连接数据库"></p><hr><p>运行时可能会出现如下错误：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_15.png" alt="连接数据库"></p><p>注释代码 <code>USE[模型名字]</code> ，重新运行即可，例如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET QUOTED_IDENTIFIER OFF;</span><br><span class="line">GO</span><br><span class="line">--USE [AdoNetProjectData];</span><br><span class="line">--GO</span><br><span class="line">IF SCHEMA_ID(N&#x27;dbo&#x27;) IS NULL EXECUTE(N&#x27;CREATE SCHEMA [dbo]&#x27;);</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><p>若执行成功，数据库中将会生成对应的表：</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_16.png" alt="连接数据库"></p><p>现在配置流程结束，接下来就可以使用了。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>因为我们创建的是一个控制台程序，此时回到 Program 入口程序，简单地添加几行测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (EntityModelContainer em = <span class="keyword">new</span> EntityModelContainer())</span><br><span class="line">        &#123;</span><br><span class="line">            em.TUserSet.Add(<span class="keyword">new</span> TUser()</span><br><span class="line">            &#123;</span><br><span class="line">                UserName = <span class="string">&quot;TestUser1&quot;</span>,</span><br><span class="line">                Password = <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            em.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会在TUserSet表中增加一行数据，点击运行完毕，查看数据库的数据表。</p><p>可以看到条目已经成功添加。</p><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_17.png" alt="连接数据库"></p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>现在就可以再次测试读取：</p><p>方法依然简单：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> (EntityModelContainer em = <span class="keyword">new</span> EntityModelContainer())</span><br><span class="line">    &#123;</span><br><span class="line">        TUser user = em.TUserSet.Find(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(user.UserName);</span><br><span class="line">        user = em.TUserSet.Where((x) =&gt; x.UserName == <span class="string">&quot;TestUser1&quot;</span>).FirstOrDefault();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>)</span><br><span class="line">            Console.WriteLine(user.UserName);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2021/2021-04-28/2021-04-28-Ado.Net%E4%B8%8EEF6.X%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8_18.png" alt="连接数据库"></p><p>正常输出。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>以上便是整个流程了，除了使用前的配置稍微有点麻烦，使用方法可真是简单惨了。</p><p>本文描述了一个最简单的使用流程，以EF设计器模型为例，使用SQLserver数据库的方式，因为这是自带的——不用过多的额外设置。</p><p>但是除此之外，它还是支持其它诸多数据库的，不过需要些额外操作就是了。</p><p>具体可以参看官方文档：<a href="https://docs.microsoft.com/en-us/ef/core/providers">支持列表</a><br>(链接接似乎是EF Core，不过不要在意细节，EF6一般也是能在NuGet上找到支持的)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ADO.NET是微软提供的一种对数据库方便操作的功能，实体框架EF6(Entity Framework 6) 应当属于其中子集。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://cwhisme.ml/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>帧同步概念</title>
    <link href="https://cwhisme.ml/2021/04/15/%E5%B8%A7%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5/"/>
    <id>https://cwhisme.ml/2021/04/15/%E5%B8%A7%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5/</id>
    <published>2021-04-15T03:52:00.000Z</published>
    <updated>2021-06-10T07:36:32.448Z</updated>
    
    <content type="html"><![CDATA[<p>网络游戏同步方式，一般分为两种：帧同步与状态同步。而帧同步所属的网络同步方式，适用于高实时性、本地表现要求比较高的情况，多数用于房间类动作游戏。例如《魔兽争霸》、《王者荣耀》等。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>游戏同步方式主要分两类：</p><h3 id="状态同步"><a href="#状态同步" class="headerlink" title="状态同步"></a>状态同步</h3><p>顾名思义，同步游戏状态，如当前血量、位置，包括各种操作都是由服务器计算，然后直接下发执行结果。</p><p>主要特点有：</p><ol><li>安全性较高。</li><li>属于不严谨同步，保证结果相同，但是不能保证同时间各客户端显示一致。</li><li>表现越复杂数据消耗越大(例如大量子弹)。</li><li>对网络的要求不高(相对)，一般使用TCP协议。</li></ol><h3 id="帧同步"><a href="#帧同步" class="headerlink" title="帧同步"></a>帧同步</h3><p>基本上由客户端计算，服务器主要起一个『转发』客户端操作的作用，表现准确度更高、效果更好，且能够像类似单击一般开发(当然还是有差异的)。理论上在每个客户端上收到相同指令的表现与结果都应当一致。而且由于仅派发玩家指令，因此数据消耗相对比较小(但是网络要求比较高)。</p><p>当然有好处，帧同步相对来说也有一些不足：</p><ul><li>网络要求比较高：因此一般采用UDP协议。</li><li>反外挂能力比较弱：因为执行逻辑都在客户端本地。</li><li>一致性错误：各个客户端处理结果产生差异(这一点在程序调试时难度尤其大)。</li><li>断线重连时间长：相对状态同步的断线重连只需要再完整请求一次数据而言，帧同步断线之后，必须通过『追帧』(也可以理解为加速播放)或重头再根据指令播放一遍抵达当前『帧』才行，这就导致更费时间。</li><li>一般只适用于人数较少的『房间类』游戏：因为接受到其他客户端的操作指令后，本地也必须真的执行计算才能得到结果，若人数过多，不说一致性问题，执行压力也会很大。</li></ul><p>总之，在看了N篇网络上各种相关文章之后，帧同步的实现大概可以总结为以下几点：</p><ol><li>显示层与逻辑层分离-&gt;保证逻辑帧为主</li><li>随机数确定-&gt;多数语言内置随机数为线性同余发生器产生，指定了随机种子后，随机序列即固定(或自己实现)</li><li>浮点数误差-&gt;作定点数处理</li><li>玩家操作同步</li></ol><p>做到上述几点之后，便可以基本保证各个客户点的一致性表现，若同时记录下玩家操作指令，后续甚至可以简单实现战斗过程的回放——因此，亦可以实现服务器重算战斗，验算战斗结果等。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="帧锁定同步"><a href="#帧锁定同步" class="headerlink" title="帧锁定同步"></a>帧锁定同步</h3><p>也叫严格的帧同步、也有人称为囚徒模式，一般为老一代的P2P局域网帧同步游戏所用，服务器每帧收集所有客户端输入指令，再统一下发。</p><p>若某个客户端出现网络延迟，没能及时上传操作，服务器也会一直等待，导致所有客户端都出现『等待』。即『网速慢的玩家会卡到网速快的玩家』。可以说所有客户端的延迟都将等于延迟最高的客户端。</p><p>这种方式实现的帧同步，由于每个客户端指令都是严格一致，一般来说同步性便不成问题。<br>就如同两个手柄插在一台主机上，两个人在一块玩游戏一样。</p><h3 id="乐观帧锁定同步"><a href="#乐观帧锁定同步" class="headerlink" title="乐观帧锁定同步"></a>乐观帧锁定同步</h3><p>网络慢的卡了，导致所有玩家都没法操作，对现在的网络游戏来说那肯定不行。</p><p>于是有了这种方式，做法就是不再锁帧，客户端及时上传操作指令，且不管某个客户端有没有上传，服务器都会定时转发接收到的操作给每个客户端。</p><p>网络慢的玩家没及时收到操作，或者没及时上传操作，影响的都只是自己本地。</p><h3 id="简单流程"><a href="#简单流程" class="headerlink" title="简单流程"></a>简单流程</h3><ol><li>战斗服发送初始数据，通知客户端准备</li><li>各客户端准备：加载场景-&gt;初始化角色-&gt;设置初始状态-&gt;向服务器发送准备完成</li><li>服务端发送开始更新消息</li><li>进入更新循环：客户端发送指令&lt;-&gt;服务器分发指令</li><li>等待结束，若需要后台验算，则结算结果等待服务器验证</li></ol><p><img src="/blogimages/2021/2021-04-15-%E5%B8%A7%E5%90%8C%E6%AD%A5%E6%A6%82%E5%BF%B5_1.png" alt="简单流程图"></p><p>上述流程目前为看了些文章之后的部分个人猜想，乐观帧锁定同步应该会更为复杂，应当还有一些额外操作或优化需要处理。不过由于目前暂未上手试验，因此也并不完全确定，实际情况得等后面实现之后才能验证了。</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>如上述所言，由于帧同步网络要求比较高，因此一般使用UDP，或者目前还有开源的<a href="https://github.com/skywind3000/kcp">KCP</a>，在UDP基础上实现的可靠UDP协议。</p><p>当然，如今随着网速的加快，TCP也不是不行。听说现在有的项目就是直接使用TCP开发，若是无法满足要求，再考虑切换至UDP。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>通常，即使是帧同步游戏，也必然存在状态同步。</p><p>例如一般的匹配游戏，在匹配进入战斗之前，各种数据等等一般均走的TCP协议，且为状态同步流程。</p><p>帧同步则用于进入『房间』之后的每场玩法逻辑的同步。</p><hr><p>参考文章：</p><ul><li><a href="http://www.skywind.me/blog/topics/network">再谈网游同步技术</a></li><li><a href="https://mp.weixin.qq.com/s/agXeHpN2vkgl5jKsLvi2Ug">王者荣耀技术总监复盘回炉历程</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA5ODExMTkwMA==&mid=2650255562&idx=1&sn=a457e6dbf7bdd99d1e75dbf7e500dd44&scene=0#wechat_redirect?ref=myread">帧同步游戏开发基础指南</a></li><li><a href="https://www.zhihu.com/search?type=content&q=%E5%B8%A7%E5%90%8C%E6%AD%A5">知乎</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;网络游戏同步方式，一般分为两种：帧同步与状态同步。而帧同步所属的网络同步方式，适用于高实时性、本地表现要求比较高的情况，多数用于房间类动作游戏。例如《魔兽争霸》、《王者荣耀》等。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="网络开发" scheme="https://cwhisme.ml/categories/%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>关于SynchronizationContext的使用</title>
    <link href="https://cwhisme.ml/2021/03/25/%E5%85%B3%E4%BA%8ESynchronizationContext/"/>
    <id>https://cwhisme.ml/2021/03/25/%E5%85%B3%E4%BA%8ESynchronizationContext/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2021-05-10T02:57:26.006Z</updated>
    
    <content type="html"><![CDATA[<p>SynchronizationContext是C#内置跨线程同步上下文的基类，可以实现线程间的同步。<br>例如，一般情况下子线程无法修改主线程的UI，通常比较麻烦的做法就是自己采用轮询机制实现同步。<br>而该类则可很方便地处理该类型问题。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档地址：<a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext?view=net-5.0">地址</a></p><p>说实话，官方文档的描述极少，大概就是说这个类是个基类，提供了一个通用的线程上下文的传递模型，有需要可以直接继承该类，并重载需要的方法，简化了多线程工作单元传递所需的工作。<br>不过在该文档中，还额外提供了一份 <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2011/february/msdn-magazine-parallel-computing-it-s-all-about-the-synchronizationcontext">MSDN的文章</a> 。<br>MSDN文章就比较详细些了。</p><p>原理就不多说了，上面MSDN文章有详细介绍，这种系统层级的东西，用就好了。<br>另外虽说称为基类，但是直接使用也是没问题的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在SynchronizationContext中，有静态的Current变量，在主UI线程调用将返回一个SynchronizationContext类型的实例。<br>同时也提供了SetSynchronizationContext(SynchronizationContext syncContext)方法可覆盖该返回值，一般用于继承了SynchronizationContext并有自己额外处理的方式的派生类使用。</p><p>可以将Current当做一个单例，但是注意的是它属于每个线程独有，在UI主线程可以直接通过SynchronizationContext.Current获取到默认的实例，但新开的子线程默认始终为Null。<br><font color=red>注：即便使用SetSynchronizationContext在主线程设置之后，新开的子线程若不进行设置，依然会保持为Null。</font></p><hr><p>SynchronizationContext类中，主要提供Post、Send两个方法进行线程回调使用：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback d, <span class="built_in">object</span> state</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Send</span>(<span class="params">SendOrPostCallback d, <span class="built_in">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure><p>其中调用Post将会异步执行，调用Send则同步执行。<code>object state</code>为调用回调时，传入的参数。</p><ul><li>Post：在调用之后，立即执行当前线程后续代码。</li><li>Send：在调用之后，等待回调执行完毕，才会继续执行当前线程后续代码。</li></ul><p>测试如下：</p><p><strong>Send</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    SynchronizationContext.Current.Send((args) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;子线程调用UI！args:<span class="subst">&#123;args&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;参数X&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用结束！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在该方法中，调用Send，并在回调内休眠1000毫秒。<br>打印结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子线程调用UI！args:参数X</span><br><span class="line">调用结束！</span><br></pre></td></tr></table></figure><p>按照顺序执行，当子线程休眠时，后续代码也阻塞未执行，直到Send回调执行完毕。</p><p><strong>Post</strong></p><p>直接将上述代码中的Send改为Post，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用结束！</span><br><span class="line">子线程调用UI！args:参数X</span><br></pre></td></tr></table></figure><p>即使去掉回调中的1000毫秒休眠，调用Post，依然会是该结果。</p><p>因此可以表明：Post可用于异步回调，Send可用于等待回调执行，需要阻塞后续代码的情况。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h3><p>直接使用的方法很简单，这里先来看WPF中的效果。</p><p>正常情况下，子线程无法操作UI，若直接调用，会得到异常报错，例如如下代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TestBtn.Content = <span class="string">&quot;子线程调用UI！&quot;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>会得到如下报错：</p><p><img src="/blogimages/2021/2021-03-25-%E5%85%B3%E4%BA%8ESynchronizationContext_1.png" alt="错误"></p><p>在WPF中，虽然有其它方式可以避免报错并让其正常工作，例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    TestBtn.Dispatcher.Invoke(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        TestBtn.Content = <span class="string">&quot;子线程调用UI！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不过这种方式是WPF自己的特性，如果想在其它地方使用，比如Unity，可就没这种东西了。</p><p>此时便可使用SynchronizationContext：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SynchronizationContext context = SynchronizationContext.Current;</span><br><span class="line">Task.Run(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">    SynchronizationContext.Current.Send((args) =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;子线程调用UI！&quot;</span>);</span><br><span class="line">        TestBtn.Content = <span class="string">&quot;子线程调用UI！&quot;</span>;</span><br><span class="line">    &#125;, <span class="literal">null</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;调用结束！&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该份代码复制至Unity，且调用UI替换为Unity的函数，亦可正常工作：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SynchronizationContext context = SynchronizationContext.Current;</span><br><span class="line">    Task.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        SynchronizationContext.SetSynchronizationContext(context);</span><br><span class="line">        Console.WriteLine(SynchronizationContext.Current.GetHashCode());</span><br><span class="line">        SynchronizationContext.Current.Send((args) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;子线程调用UI！&quot;</span>);</span><br><span class="line">            UnityEditor.EditorUtility.DisplayDialog(<span class="string">&quot;提示&quot;</span>, <span class="string">&quot;子线程的调用！&quot;</span>, <span class="string">&quot;OK&quot;</span>);</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;调用结束！&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2021/2021-03-25-%E5%85%B3%E4%BA%8ESynchronizationContext_2.png"></p><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>一般在项目中，代码结构都不会如此简单，如果在开启子线程时，处处考虑SynchronizationContext实例线程传递的话，也比较麻烦。因此可以使用单例。</p><p>这里主要有两种方式实现：</p><ul><li>普通单例缓存SynchronizationContext实例</li><li>继承自SynchronizationContext的单例实现</li></ul><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>第一种比较好说，直接新建一个单例类，并将SynchronizationContext封装即可。<br>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MySynchronizationContextHolder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySynchronizationContextHolder Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> MySynchronizationContextHolder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SynchronizationContext _context = SynchronizationContext.Current;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> _mainThreadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">Action action, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Post(<span class="keyword">new</span> SendOrPostCallback((x) =&gt; action.Invoke()), state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback callback, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.CurrentThread.ManagedThreadId == _mainThreadId)</span><br><span class="line">        &#123;</span><br><span class="line">            callback.Invoke(state);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _context.Post(callback, state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此种方式唯一需要注意的是：子线程调用实例之前，主线程必须先调用一次，确保单例初始化于主线程，否则初始化于子线程的单例会造成错误的结果。<br>(例如上述方式，若第一次由子线程初始化调用，会导致_context实例为Null，而且由于处于子线程甚至无法捕获错误。)</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>第二种方式，由于继承了SynchronizationContext，就不能简单地通过调用<code>base.Post(callback,state);</code>这种方法来实现传递了。<br>因为那样的话，这个单例就会变成跟子线程调用一样的性质了：<br>直接调用的情况就如同子线程直接创建了一个新实例，然后调用造成的结果，跟子线程直接调用无所区别。</p><p>因此这里就需要额外做点工作，比如重写方法，缓存回调，然后在主线程Update中统一更新：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MySynchronizationContext</span> : <span class="title">SynchronizationContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MySynchronizationContext Instance &#123; <span class="keyword">get</span>; &#125; = <span class="keyword">new</span> MySynchronizationContext();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConcurrentQueue</span>&lt;<span class="title">Action</span>&gt; _queue</span> = <span class="keyword">new</span> ConcurrentQueue&lt;Action&gt;();</span><br><span class="line">    <span class="keyword">private</span> Action _callback;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_queue.Count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!_queue.TryDequeue(<span class="keyword">out</span> _callback))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            _callback.Invoke();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;action&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">Action action, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Post(<span class="keyword">new</span> SendOrPostCallback((x) =&gt; action.Invoke()), state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 子线程执行一个回调时调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;callback&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;state&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Post</span>(<span class="params">SendOrPostCallback callback, <span class="built_in">object</span> state</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _queue.Enqueue(() =&gt; callback.Invoke(state));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是两个可以将SynchronizationContext封装为单例的实现方式。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>个人感觉，这种一般在多线程使用中还是挺有用的——比自己去循环查询结果来得方便。</p><p>此前个人就经常使用那种笨办法，比如制作Unity工具，在子线程回调中需要表现的时候：弹窗或者显示进度条，就是在使用回调修改值，然后在界面中再根据回调修改后的值判断是否进行显示，<br>中间转化及其麻烦，有时候甚至直接就因此放弃做什么表现了，直接一个子线程搞完了再统一给个回复。</p><p>后续就会考虑实际应用，或许修改下以前的代码了。<br>如Github上一些小工具，后续应该会考虑更新一波。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SynchronizationContext是C#内置跨线程同步上下文的基类，可以实现线程间的同步。&lt;br&gt;例如，一般情况下子线程无法修改主线程的UI，通常比较麻烦的做法就是自己采用轮询机制实现同步。&lt;br&gt;而该类则可很方便地处理该类型问题。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;</summary>
      
    
    
    
    <category term="C#" scheme="https://cwhisme.ml/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Unity3D中Sahder深度图及应用</title>
    <link href="https://cwhisme.ml/2021/03/10/Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://cwhisme.ml/2021/03/10/Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2021-03-09T16:00:00.000Z</published>
    <updated>2021-06-10T10:09:20.838Z</updated>
    
    <content type="html"><![CDATA[<p>关于Sahder中的深度图，其应用方式有很多，最常见的例如 科幻游戏中扫描线、水的Shader、透明物体相交、屏幕后期处理的描边等。<br>主要就是因为在能够获得场景深度值之后，可以有许多操作空间。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章，其实在之前整理『Unity3DSahder关键字』及『Sahder内置函数』的时候就在想写一下了。<br>不过在那之后，有几个原因导致一直没有动手：</p><ul><li>感觉只是个小东西，复杂之处在于用它来实现的各种后期效果；</li><li>虽然知道原理，但自己动手搞了搞之后，感觉理解起来有点困惑，这样就更不好说写什么了；</li><li>网上相关文章也挺多；<br>另外也有点其他事情耽搁了。</li></ul><p>不过后面考虑了下，不写写加深理解，总结实践下，那后面再遗忘可就真没收获了。<br>因此在这里，我会简单总结一下深度图分别在屏幕后期处理及单个物体Shader中的用法及作用。</p><h2 id="获取深度图"><a href="#获取深度图" class="headerlink" title="获取深度图"></a>获取深度图</h2><p>在获取深度值方面，主要有两种方式：</p><ol><li>通过获取整个屏幕深度图</li><li>在单个物体特殊应用时，获取自身深度值</li></ol><p>在Unity中，引擎是直接提供了屏幕深度图的，使用方式也很简单：在Shader中声明 <code>sampler2D _CameraDepthTexture;</code>变量即可，运行时Unity会自动为其赋值。<br>然后通过纹理采样函数，即可获取到指定 屏幕坐标 的深度值信息。<br>注意采样到的深度值，并非线性[0,1]深度值，可使用Unity提供的函数Linear01Depth转化。</p><p><font color=red>注：仅“不透明”对象（这些对象的材质和着色器设置为使用小于等于 2500 的渲染队列）会自动被渲染到深度纹理中</font></p><p>另外在这里还需要注意两点：屏幕后期处理Shader与物体自身Sahder采样的差异。</p><h3 id="屏幕后处理对深度图采样"><a href="#屏幕后处理对深度图采样" class="headerlink" title="屏幕后处理对深度图采样"></a>屏幕后处理对深度图采样</h3><p>屏幕后期处理Sahder采样方式比较简单，直接将i.uv传入采样函数，返回的即是屏幕对应位置的深度值。</p><p>片元处理函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float depth = Linear01Depth(tex2D(_CameraDepthTexture, i.uv).x);</span><br></pre></td></tr></table></figure><h3 id="物体对屏幕深度值采样"><a href="#物体对屏幕深度值采样" class="headerlink" title="物体对屏幕深度值采样"></a>物体对屏幕深度值采样</h3><p>不过若使用者是某个物体的Sahder，那么就不能直接通过uv去采用深度了；这也是理所当然，物体uv跟屏幕坐标可没有半分关系。<br>因此需要计算出顶点所在的屏幕空间坐标，然后将屏幕空间坐标当做uv对深度图进行采样。</p><p>Unity同样提供了对应函数<code>ComputeScreenPos(x)</code>，其中x是投影空间坐标。<br>在顶点处理函数传入片元数据结构体中，定义一个四维变量，调用该方法即可获取屏幕坐标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.screenPos=ComputeScreenPos(o.vertex);</span><br></pre></td></tr></table></figure><p>然后在片元处理函数中，进行纹理采样。<br>注意此处是使用tex2Dproj采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float sceneZ = tex2Dproj(_CameraDepthTexture,i.screenPos).x;</span><br></pre></td></tr></table></figure><p>或者使用tex2D，手动除以w分量亦可：<br>(注：原因是uv采样值范围是[0,1]，因此计算出来的屏幕坐标需除以w分量映射至[0,1]区间)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float sceneZ = tex2D(_CameraDepthTexture,i.screenPos.xy/i.screenPos.w).x;</span><br></pre></td></tr></table></figure><p>直接将采样的深度值作为颜色输出效果：</p><p><img src="/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_1.png" alt="物体采样(左)后处理屏幕采样(右)"><br>(物体采样(左)后处理屏幕采样(右))</p><h2 id="屏幕后处理对深度值的应用"><a href="#屏幕后处理对深度值的应用" class="headerlink" title="屏幕后处理对深度值的应用"></a>屏幕后处理对深度值的应用</h2><p>关于屏幕后处理对深度图的应用，最简单的，大约要数“扫描线”这种了。<br>单纯地对比当前深度值及距离，就可以做出一个效果，网络上大多数关于深度图的文章，似乎也是第一个就在讲这个。</p><p>因此，秉着从简单开始原则，我也来一份。</p><p>首先，为了简单起见，这里就不使用其它什么额外效果，直接定义两个所需的基础变量：</p><ul><li>_Depth 作为当前深度距离</li><li>_Width 作为扫描线的宽度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_Width(&quot;Width&quot;,Float) = 0.1</span><br><span class="line">_Depth(&quot;Depth&quot;,Range(0,1)) = 0.1</span><br></pre></td></tr></table></figure><p>然后，在片元处理函数中，分别采样屏幕原图和深度图。<br>这时候就可以通过 _Depth参数 和深度图中的数值进行对比，计算结果。</p><p>判断标准是什么？</p><ul><li>深度值小于 _Depth</li><li>深度值大于 _Depth-_Width 形成宽度<br>在这个区间内，可以形成一条宽度 _Width 的横线</li></ul><p>如下代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//采样屏幕原图</span><br><span class="line">float4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">//采样深度图</span><br><span class="line">float depth = Linear01Depth(tex2D(_CameraDepthTexture, i.uv).x);</span><br><span class="line">float distance = _Depth;</span><br><span class="line">//判断深度值是否处于当前设置的区间内</span><br><span class="line">if (depth &lt; distance &amp;&amp; depth&gt; distance - _Width) &#123;</span><br><span class="line">return float4(1, 0, 0, 1)+col;</span><br><span class="line">&#125;</span><br><span class="line">return col;</span><br></pre></td></tr></table></figure><p><img src="/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_2.gif" alt="最基础的效果"><br>(最基础的效果)</p><p>在这块代码中，判断当深度值处于当前设置区间内，则直接将红色与当前颜色融合，否则返回当前颜色。很简单的一个逻辑。</p><p>如果觉得这条横线的边太硬，想稍微加点效果的话，还可以根据当前颜色深度所处宽度比例，作边缘柔化处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float diff = 1 - (distance - depth) / _Width;</span><br><span class="line">return float4(1, 0, 0, 1)*diff+col;</span><br></pre></td></tr></table></figure><p>由于上面是深度位于 distance - _Width 区间才会进来，所以 distance - depth 取值范围为 [0,_Width]。<br>因此 distance - depth 便是当前所处区间的位置，除以宽度，得出当前所处位置的比例。根据比例逐步提高线条颜色值，可以形成一个简易的柔化效果。</p><p><img src="/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_3.png" alt="加柔边效果"><br>(加柔边效果)</p><p>屏幕后期处理中，上述只是最简单和基础的一个应用，深度图的作用还有做屏幕描边啊、模糊，做雾效等等，在此就不多说了。</p><h2 id="物体Shader对深度值的应用"><a href="#物体Shader对深度值的应用" class="headerlink" title="物体Shader对深度值的应用"></a>物体Shader对深度值的应用</h2><p>在物体Sahder中，如果需要获取深度图，那么一般来说，自身深度都是不写入深度图的，ZWrite通常为<code>ZWrite Off</code>。</p><p>因此主要有两个操作：</p><ul><li>计算自身深度值</li><li>采样自身位置原本深度值</li></ul><p>然后通过两者相差，进行深度比较执行其它逻辑。<br>最常见的例如水的Shader，在靠近岸边的时候波浪、渐变效果，物体相交检测等。应用方面，这里主要就说一下物体相交检测的效果。</p><p>为了计算自身深度，可以直接使用Unity提供函数COMPUTE_EYEDEPTH(x)，需要在顶点处理函数中调用，返回当前顶点深度值。</p><p>为了采样自身原本位置深度值，需要计算出当前顶点对应屏幕坐标，然后对深度图进行采样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v2f:</span><br><span class="line">float4 screenPos: TEXCOORD3;</span><br><span class="line"></span><br><span class="line">vert:</span><br><span class="line">o.screenPos = ComputeScreenPos(o.vertex);</span><br><span class="line">COMPUTE_EYEDEPTH(o.screenPos.z);</span><br></pre></td></tr></table></figure><p>由于计算出来的屏幕坐标，z值实际上是没用的(投影纹理查询只用到xy/w)，因此可以直接将自己的深度值存放至screenPos的z值中，传入片元处理函数。</p><p>来到片元处理函数后，采样深度图中的深度值，并将其与物体当前深度值进行对比，直接输出，可得到如下效果：</p><p><img src="/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_4.png" alt="效果"></p><p>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//场景深度</span><br><span class="line">float sceneZ = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,i.screenPos).x);</span><br><span class="line">//自身深度</span><br><span class="line">float selfZ = (i.screenPos.z);</span><br><span class="line">//取得差值</span><br><span class="line">float diff =  (sceneZ-selfZ );</span><br><span class="line">//输出差值</span><br><span class="line">return float4(diff, diff, diff,1);</span><br></pre></td></tr></table></figure><p>我们需要实现一个 相交描边 的效果，那么可以定义一个描边强度值<code>_OutLineValue(&quot;RimValue&quot;, Range(0,1)) = 0.1</code><br>大于该值输出描边颜色，否则可以输出黑色。<br>将直接返回深度差值修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return float4(step(diff, _OutLineValue) , 0, 0, 0.5);</span><br></pre></td></tr></table></figure><p>step为shder内置函数，step(diff, _OutLineValue)表示，当diff小于_OutLineValue时，返回1，diff大于_OutLineValue时，返回0。<br>直接当做R通道颜色放进去，可以方便低实现：深度值低于_OutLineValue显示红色描边 的需求。</p><p><img src="/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_5.png" alt="效果"></p><p>如此，最简单的一个 相交描边 效果就实现了，代码很简单，所以效果也很简陋。</p><p>为了优化点显示的话，可以加一点其它效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//场景深度</span><br><span class="line">float sceneZ = LinearEyeDepth(tex2Dproj(_CameraDepthTexture,i.screenPos).x);</span><br><span class="line">//自身深度</span><br><span class="line">float selfZ = (i.screenPos.z);</span><br><span class="line">//取得差值</span><br><span class="line">float diff =  (sceneZ-selfZ);</span><br><span class="line">//计算相交的描边强度</span><br><span class="line">float outLineStrenth =1- saturate(diff / _OutLineValue);</span><br><span class="line">//计算视线夹角，实现轮廓高亮</span><br><span class="line">float rimStrenth=1-abs(dot(i.normal, i.viewDir))*_RimValue;</span><br><span class="line">return float4(0,0,0,0.5)+float4(1,0,0,0)*max(outLineStrenth, rimStrenth);</span><br></pre></td></tr></table></figure><p>因为这里的物体是透明且双面显示，因此需要处理法线与视线为负的情况，这里直接将点乘结果转化为绝对值的正数。<br>最终返回值为半透明黑色叠加相交描边或轮廓颜色：在这里取两者最大值，可以保证相交和轮廓因为视角原因叠在一块的时候，可以优先展示程度更深的一方，效果更好。</p><p>另外外边缘轮廓还可以直接使用菲涅尔效果展示(比上面单纯视线和法线夹角好用，当然计算也稍微多一点)。</p><p>一般游戏中，使用的简化版菲涅尔公式为：</p><p>$$<br>fresnel=(1-(N \cdot V))^5*强度<br>$$</p><p>代码可修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float rim=pow(1-abs(dot(i.normal, i.viewDir)), 5)*_RimValue;</span><br></pre></td></tr></table></figure><p>当然，其中5这个定量也可以修改为变量，已进行更细致的效果调整。</p><p><img src="/blogimages/2021/2021-03-10-Sahder%E4%B8%AD%E6%B7%B1%E5%BA%A6%E5%9B%BE%E5%8F%8A%E5%BA%94%E7%94%A8_6.png" alt="效果 直接轮廓高亮(左) 菲涅尔(右)"><br>(效果 直接轮廓高亮(左) 菲涅尔(右))</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是深度图最简答的两个不同应用。<br>这次也是一边实践一边Bing一边写，花了两天多时间，总算收尾了。<br>怎么说呢，这一趟下来，还是有收获的。之前虽然知道大概怎么做，但实际理解起来还是有点糊的，因为自己不理解的也不敢直接写，所以从易到难一遍想一边慢慢再实现一遍，至少很多之前不太理解的地方也算想通了。</p><p>后边除非许久不再研究这一块，就算忘了，看看自己写的文章，应该也能很快拾起来吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于Sahder中的深度图，其应用方式有很多，最常见的例如 科幻游戏中扫描线、水的Shader、透明物体相交、屏幕后期处理的描边等。&lt;br&gt;主要就是因为在能够获得场景深度值之后，可以有许多操作空间。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/categories/Unity3D/"/>
    
    
    <category term="Shader" scheme="https://cwhisme.ml/tags/Shader/"/>
    
    <category term="Unity3D" scheme="https://cwhisme.ml/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>网络协议加密</title>
    <link href="https://cwhisme.ml/2021/03/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%AF%86/"/>
    <id>https://cwhisme.ml/2021/03/09/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%AF%86/</id>
    <published>2021-03-08T16:00:00.000Z</published>
    <updated>2021-06-10T10:06:22.539Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，现在网络通信的时候，协议之间一般都会进行加密，以防第三方抓包等进行破解。再不济也会进行异或混淆。在这里我就记录一下自己的一个网络框架『CrySimpleNet』进行协议加密的结构。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>CrySimpleNet开发的初衷，主要是当年接手公司项目维护之后，意图实现一套『远程打包』。</p><p>比如，在自己的机器上，使用一个客户端，点击对应选项，就可以自动在打包机上调用Unity3D进行相应操作：如自动合并SVN打热更、更新项目出包等等。</p><p>这个网络框架的目的是：使得打包者可以直接调用客户端，通知Windows打包机进行各项操作，Android打包就简单，直接全是Windows打包机操作就行了，最多不过在让Unity导出项目之后，需要再额外调用Android Studio进行最终打包。<br>不过IOS项目打包则需要在导出Xcode工程后，将工程数据传输到Mac打包机调用Xcode进行最终打包。此不多言。</p><p>不过后面在实现网络方面功能、然后测试了框架文件传输效果后，被告知打包机不能被直连：因为担心网络安全；因此这个计划就放弃了。<br>后期打包主要操作和工具还是做到了UnityEditor中。</p><p>还好这个框架在实现的时候，就考虑了重用性，核心库不管是放Unity，还是放WPF都可以用。现在用不上，以后说不准哪里还能用到。<br>毕竟自己实现的东西，跟网上随便找的框架，用起来可不一样。</p><p>放了这么些时日，想起当初对协议传输加密方面，只简单实现了 异或混淆、压缩等操作，加密性应该算是比较低的。包括数据包完整性校验也没做，于是花了点时间，将其补上了。</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p><span>加密结构：异或加密【RSA加密标志(1)|RSA加密【MD5校验位+压缩位|实际数据|MD5校验数据(16位或者0)】】</span></p><p>由于协议结构是个人琢磨的，若有不足还请指正。</p><p>其操作顺序为：</p><ol><li>首先判断是否压缩：数据包大小超出压缩上限</li><li>若需要压缩，则将原数据压缩成一个新的比特数组</li><li>创建一个包括 MD5标志、压缩标志和目前数据包长度 大小的新数组</li><li>数组第0位写入MD5校验标志及压缩标志(之所以写入MD5标志位，是因为MD5校验做成了可通过配置进行开启或关闭)</li><li>写入实际数据</li><li>写入MD5校验数据(如果有的话)</li><li>RSA加密：写入RSA标志位，写入加密数据(同样可通过配置开启或关闭)</li><li>异或混淆</li></ol><p>解密顺序则通过相反顺序操作进行。</p><ol><li>异或混淆解密</li><li>判断是否RSA加密，并进行解密</li><li>取出MD5标志、取出压缩标志</li><li>取出老的MD5码</li><li>取出实际数据</li><li>判断是否进行MD5校验，若有则计算实际数据MD5，并与老的MD5码对比</li><li>判断是否压缩、解压缩</li></ol><p>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加密结构：异或加密【RSA加密标志(1)|RSA加密【MD5校验位+压缩位|实际数据|MD5校验数据(16位或者0)】】</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bytes&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;compress&quot;&gt;</span>是否压缩<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rsaEncrypt&quot;&gt;</span>是否rsa加密<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ByteEncryption</span>(<span class="params"><span class="built_in">byte</span>[] bytes, <span class="built_in">bool</span> compress = <span class="literal">true</span>, <span class="built_in">bool</span> rsaEncrypt = <span class="literal">false</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span>[] compressBytes = bytes;</span><br><span class="line">    <span class="comment">//压缩</span></span><br><span class="line">    <span class="keyword">if</span> (compress)</span><br><span class="line">        compressBytes = Compress(compressBytes);</span><br><span class="line">    <span class="comment">//写入标志</span></span><br><span class="line">    <span class="comment">//注：MD5加密，则位数为16位MD5+MD5标志位@压缩标志位</span></span><br><span class="line">    <span class="comment">//      否则为 MD5标志位@压缩标志位</span></span><br><span class="line">    <span class="built_in">byte</span>[] tempBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[(Config.IsProtoMD5Verification ? compressBytes.Length + <span class="number">16</span> : compressBytes.Length) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//byte类型标志位最大支持7个：byte b = 1 &lt;&lt; 1 | 1 &lt;&lt; 2 | 1 &lt;&lt; 3 | 1 &lt;&lt; 4 | 1 &lt;&lt; 5 | 1 &lt;&lt; 6 | 1 &lt;&lt; 7=254;</span></span><br><span class="line">    <span class="built_in">int</span> flagByte = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//写入MD5校验位</span></span><br><span class="line">    flagByte |= (Config.IsProtoMD5Verification ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//写入压缩位</span></span><br><span class="line">    flagByte |= (compress ? <span class="number">1</span> : <span class="number">0</span>) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    tempBytes[index++] = (<span class="built_in">byte</span>)flagByte;</span><br><span class="line">    <span class="comment">//写入实际数据</span></span><br><span class="line">    compressBytes.CopyTo(tempBytes, index);</span><br><span class="line">    index += compressBytes.Length;</span><br><span class="line">    <span class="comment">//写入MD5校验数据</span></span><br><span class="line">    <span class="keyword">if</span> (Config.IsProtoMD5Verification)</span><br><span class="line">    &#123;</span><br><span class="line">        CalcMD5(compressBytes).CopyTo(tempBytes, index);</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//内容 加密</span></span><br><span class="line">    tempBytes = EncryptRawContent(tempBytes, rsaEncrypt);</span><br><span class="line">    <span class="comment">//混淆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; tempBytes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempBytes[i] ^= Config.XorKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tempBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 解密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bytes&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">ByteDecrypt</span>(<span class="params"><span class="built_in">byte</span>[] bytes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//解混</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; bytes.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes[i] ^= Config.XorKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内容解密</span></span><br><span class="line">    bytes = DecryptRawContent(bytes);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取标志位信息</span></span><br><span class="line">    <span class="built_in">byte</span> flagByte = bytes[index++];</span><br><span class="line">    <span class="comment">//读取MD5校验标志</span></span><br><span class="line">    <span class="built_in">bool</span> isMd5Verify = (flagByte &amp; <span class="number">1</span> &lt;&lt; <span class="number">1</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//读取压缩标志</span></span><br><span class="line">    <span class="built_in">bool</span> isCompress = (flagByte &amp; <span class="number">1</span> &lt;&lt; <span class="number">2</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//MD5校验数据保存在最后，这里如果有的话就要删掉</span></span><br><span class="line">    <span class="built_in">int</span> contentLength = bytes.Length - index;</span><br><span class="line">    contentLength = isMd5Verify ? contentLength - <span class="number">16</span> : contentLength;</span><br><span class="line">    <span class="built_in">byte</span>[] rawBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[contentLength];</span><br><span class="line">    Array.Copy(bytes, index, rawBytes, <span class="number">0</span>, contentLength);</span><br><span class="line">    index += contentLength;</span><br><span class="line">    <span class="keyword">if</span> (isMd5Verify)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] md5Bytes = <span class="keyword">new</span> <span class="built_in">byte</span>[<span class="number">16</span>];</span><br><span class="line">        Array.Copy(bytes, index, md5Bytes, <span class="number">0</span>, md5Bytes.Length);</span><br><span class="line">        <span class="built_in">byte</span>[] nowMd5 = CalcMD5(rawBytes);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; md5Bytes.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (md5Bytes[i] != nowMd5[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Log.Error(<span class="string">$&quot;MD5校验失败！原：<span class="subst">&#123;md5Bytes.ToString()&#125;</span> ==&gt; 现<span class="subst">&#123;nowMd5&#125;</span>&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">byte</span>[] oringinByte = rawBytes;</span><br><span class="line">    <span class="comment">//解压缩</span></span><br><span class="line">    <span class="keyword">if</span> (isCompress)</span><br><span class="line">        oringinByte = Decompress(oringinByte);</span><br><span class="line">    <span class="keyword">return</span> oringinByte;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上便是整个加密结构。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p>加密结构中，加解密顺序操作即可，并无难点。需要注意的是RSA加密的问题，这里我是单独抽出了一个方法，方便排版和处理。</p><p>因为RSA加密需要秘钥，一般来说，加密者使用公钥，接收者使用私钥，成对进行。<br>因此在个人的设计中，需要有两组秘钥：</p><ul><li>服务器公钥-客户端私钥</li><li>服务器私钥-客户端公钥</li></ul><p>分别用于客户端与服务器相对发送、接收的加密、解密。</p><p>但是，RSA加密明文长度是有限制的：根据资料显示，一个公钥加密的明文长度，等于秘钥长度减11字节。<br>其中11字节是RSA算法需要占用的空间。<br>即，若秘钥长度为1024位，则明文长度最大支持 1024/8-11=117字节(1字节=8位，秘钥单位是位)<br>同时，明文加密后的长度，一定会等于秘钥长度。</p><p>因此采取了分块解密的方式。<br>假设秘钥长度为1024位，则</p><ul><li>数据块一块最多占用 maxSzie=1024/8=128Byte</li><li>明文一块最多占用 maxCap=maxSzie-11=117Byte</li></ul><p>主要操作是：</p><ol><li>判断需要加密的内容，字节数是否大于117Byte，如果小于，直接加密返回即可。</li><li>若数据大于117Byte，则根据 总量/117 并向上取整，获取分块数量。<br>之所以向上取整，是因为如果有余数，那么代表按照117Byte进行分割会有剩余字节，最后一个数据块必然是小于117Byte的。</li><li>根据得出需要分块的数量N，创建加密后总数据数组(size=N*maxSzie)容器。</li><li>进行for循环，不断加密不断填充，完成加密。</li></ol><p>代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> RSA 加密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;val&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">EncryptRSA</span>(<span class="params"><span class="built_in">byte</span>[] val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_rsaEncrypt == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rsaEncrypt = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">        _rsaEncrypt.FromXmlString(Config.RSAPublicKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Rsa加密最大允许秘钥长度-11的加密内容</span></span><br><span class="line">    <span class="comment">//例如1024/8=128个字节-11=117字节</span></span><br><span class="line">    <span class="comment">//因此需要分割加密</span></span><br><span class="line">    <span class="built_in">int</span> maxSize = _rsaEncrypt.KeySize / <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">int</span> maxCap = maxSize - <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (val.Length &gt; maxCap)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = (<span class="built_in">int</span>)Math.Ceiling(val.Length / (<span class="built_in">float</span>)maxCap);</span><br><span class="line">        <span class="comment">//最终数据</span></span><br><span class="line">        <span class="built_in">byte</span>[] finalBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[num * maxSize];</span><br><span class="line">        <span class="comment">//每一片的实际数据</span></span><br><span class="line">        <span class="built_in">byte</span>[] piceRawBytes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> index = i * maxCap;</span><br><span class="line">            piceRawBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[val.Length - index &gt; maxCap ? maxCap : val.Length - index];</span><br><span class="line">            Array.Copy(val, index, piceRawBytes, <span class="number">0</span>, piceRawBytes.Length);</span><br><span class="line">            <span class="built_in">byte</span>[] bytes = _rsaEncrypt.Encrypt(piceRawBytes, <span class="literal">false</span>);</span><br><span class="line">            bytes.CopyTo(finalBytes, i * maxSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> finalBytes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _rsaEncrypt.Encrypt(val, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于分块之后，最后一块的数据内容不规则，因此需要特殊处理一下最后一块的数据。</p><p>解密方式则通过类似操作进行，分块解密，然后统一合并，形成最终明文数据：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> RSA 解密</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;val&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">byte</span>[] <span class="title">DecryptRSA</span>(<span class="params"><span class="built_in">byte</span>[] val</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_rsaDecrypt == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _rsaDecrypt = <span class="keyword">new</span> RSACryptoServiceProvider();</span><br><span class="line">        _rsaDecrypt.FromXmlString(Config.RSAPrivateKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Rsa加密最大允许秘钥长度-11的加密内容</span></span><br><span class="line">    <span class="comment">//例如1024/8=128个字节-11=117字节</span></span><br><span class="line">    <span class="comment">//因此需要分割解密</span></span><br><span class="line">    <span class="built_in">int</span> maxSize = _rsaDecrypt.KeySize / <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">int</span> maxCap = maxSize - <span class="number">11</span>;</span><br><span class="line">    <span class="comment">//大于秘钥最大支持长度，估计是分割过的内容</span></span><br><span class="line">    <span class="keyword">if</span> (val.Length &gt; maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> num = val.Length / maxSize;</span><br><span class="line">        <span class="keyword">using</span> (MemoryStream stream = <span class="keyword">new</span> MemoryStream())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">byte</span>[] lockBytes = <span class="keyword">new</span> <span class="built_in">byte</span>[maxSize];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Array.Copy(val, i * maxSize, lockBytes, <span class="number">0</span>, lockBytes.Length);</span><br><span class="line">                <span class="built_in">byte</span>[] unlockBytes = _rsaDecrypt.Decrypt(lockBytes, <span class="literal">false</span>);</span><br><span class="line">                stream.Write(unlockBytes, <span class="number">0</span>, unlockBytes.Length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stream.ToArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _rsaDecrypt.Decrypt(val, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可否认的是，RSA加密及分块加解密这种方式肯定也会给性能带来影响。<br>不过现在还是以安全为准，而且结构在这儿，就算更换加密方式也是很简单的。</p><p>增加数据MD5校验及RSA加密后，调用GenerateRsaKey方法生成一对公钥及私钥，进行简单的通信测试<br>(正常情况应该生成两对，服务器及客户端相对配置，这里为了方便就直接用一对进行测试了，双方都使用同一对公钥私钥进行加解密)</p><p>内容能够正常传输，未发现问题，说明加解密正常。</p><p><img src="/blogimages/2021/2021-03-09-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8A%A0%E5%AF%86_1.png" alt="效果"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;众所周知，现在网络通信的时候，协议之间一般都会进行加密，以防第三方抓包等进行破解。再不济也会进行异或混淆。在这里我就记录一下自己的一个网络框架『CrySimpleNet』进行协议加密的结构。&lt;/p&gt;
&lt;h2 id=&quot;0x01&quot;&gt;&lt;a href=&quot;#0x01&quot; class=&quot;</summary>
      
    
    
    
    <category term="网络开发" scheme="https://cwhisme.ml/categories/%E7%BD%91%E7%BB%9C%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Sahder内置函数</title>
    <link href="https://cwhisme.ml/2021/02/02/Sahder%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>https://cwhisme.ml/2021/02/02/Sahder%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/</id>
    <published>2021-02-02T03:05:45.000Z</published>
    <updated>2021-06-11T04:10:54.837Z</updated>
    
    <content type="html"><![CDATA[<p>Shader内置函数记录，特指可在Unity3D中使用的，且个人测试使用过的。</p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回x的绝对值</td></tr><tr><td>ceil(x)</td><td>向上取整，返回不小于x的最小整数</td></tr><tr><td>lerp(a,b,f)</td><td>线性插值：$(1 – f )\times a + b \times f$，其中f可以是标量，也可以是与a和b类型相同的向量。</td></tr><tr><td>smoothstep(min,max,x)</td><td>返回 min 到 max 的平滑变化值，x值范围需求0~1；公式：<span>$-2\times(\frac{((x-min)}{(max-min))})^3+3\times(\frac{((x-min)}{(max-min))})^2$</span></td></tr><tr><td>step(a,x)</td><td>x&gt;=a?1:0</td></tr><tr><td>floor(x)</td><td>向下取整，返回不大于x的最大整数</td></tr><tr><td>max(a,b)</td><td>返回a、b中最大值</td></tr><tr><td>min(a,b)</td><td>返回a、b中最小值</td></tr><tr><td>round(x)</td><td>返回x的四舍五入值</td></tr><tr><td>clamp(x,a,b)</td><td>将x限制在a~b范围内；若x在a、b范围内则返回x，若x小于a则返回a，若x大于b则返回b</td></tr><tr><td>saturate(x)</td><td>将x值限制在 [0,1] 范围内</td></tr><tr><td>frac(x)</td><td>取x的小数位部分</td></tr><tr><td>sign(x)</td><td>若x&gt;0则返回1，若x&lt;0则返回-1，否则返回0</td></tr><tr><td>modf(x,ip[out])</td><td>将x拆分为小数和整数两部分，返回小数，并将整数部分赋值于ip</td></tr><tr><td>cross(A,B)</td><td>返回向量A与B的叉积，A与B必须为三维向量</td></tr><tr><td>dot(A,B)</td><td>返回向量A与B的点积</td></tr><tr><td>fmod(x,y)</td><td>返回 x 除以 y 的余数</td></tr><tr><td>pow(x,y)</td><td>$x^y$</td></tr><tr><td>sqrt(x)</td><td>返回x的平方根，x必须大于0</td></tr><tr><td>rsqrt(x)</td><td>返回x的倒数平方根（$\frac 1 {sqrt(x)}$），x必须大于0</td></tr><tr><td>exp(x)</td><td>返回指数函数 $e^x$</td></tr><tr><td>exp2(x)</td><td>返回指数函数 2$^x$</td></tr><tr><td>all(x)</td><td>如果x的每个值都不为0，则返回true，否则返回false(可当做1、0)</td></tr><tr><td>any(x)</td><td>只要x有一个值不为0，就返回true，否则返回false</td></tr><tr><td>sin(x)</td><td>取x的正弦，返回值范围为 [-1，1]</td></tr><tr><td>cos(x)</td><td>取x的余弦，返回值范围为 [-1，1]</td></tr><tr><td>sincos(float x,s[out],c[out])</td><td>返回x的，s：正弦、c：余弦；适用于需要同时计算sin、cos的情况，性能比单独计算更好</td></tr><tr><td>tan(x)</td><td>取x的正切</td></tr><tr><td>sinh(x)</td><td>取x的双曲正弦，返回值范围为 [$-\infty,+\infty$]</td></tr><tr><td>cosh(x)</td><td>取x的双曲余弦，返回值范围为 [1,$+\infty$]</td></tr><tr><td>tanh(x)</td><td>取x的双曲正切，返回值范围为 [-1,+1]；有公式：$tanh(x)=\frac{sinh(x)}{cosh(x)}=\frac{e^x-e^{-x}}{e^x+e^{-x}}  [注:(sinh(x)\neq{e^x-e^{-x}}) (cosh(x)\neq{e^x+e^{-x}})]$</td></tr><tr><td>asin(x)</td><td>取x的反正弦，返回值范围为<span>[$-\frac\pi2, \frac\pi2$]</span>，传入的x值必须在[–1, 1]范围内</td></tr><tr><td>acos(x)</td><td>取x的反余弦，返回值范围为[0, $\pi$]，传入的x值必须在[–1, 1]范围内</td></tr><tr><td>atan(x)</td><td>取x的反正切，返回值范围为<span>[$-\frac\pi2, \frac\pi2$]</span></td></tr><tr><td>atan2(y,x)</td><td>取 y/x 的反正切，返回值范围为<span>[$-\pi, \pi$]</span></td></tr><tr><td>degrees(x)</td><td>将作为弧度值的x转换为角度</td></tr><tr><td>radians(x)</td><td>将作为角度值的x转换为弧度</td></tr><tr><td>determinant(M)</td><td>取矩阵M的行列式（返回似乎是行列式的一个值，可当float用）</td></tr><tr><td>frexp(x,exp[out])</td><td>把 x 分解成尾数和指数。返回值是尾数，并将指数存入 exp 中。所得的值是 x = 尾数 * 2 ^ exp。<a href="(https://www.runoob.com/cprogramming/c-function-frexp.html)">参考</a></td></tr><tr><td>isfinite(x)</td><td>如果x值有限，返回true</td></tr><tr><td>isinf(x)</td><td>如果x值无限，返回true</td></tr><tr><td>isnan(x)</td><td>如果x不是数字，返回true</td></tr><tr><td>ldexp(x,n)</td><td>返回 x 乘以 2 的 n 次幂 ($x\times2^n$)</td></tr><tr><td>lit(NdotL,NdotH,m)</td><td>计算环境光、漫射光和镜面光贡献的照明系数。返回值为四维向量：x为环境光系数，总是为1；y为漫反射系数，如果NdotL小于0则为0，否则为NdotL；z为镜面系数，如果NdotL或NdotH任一小于0则为0，否则返回$(N \cdot H)^m$</td></tr><tr><td>log(x)</td><td>返回x的自然对数(底为e=2.71828…)，x必须大于0  (注：对数函数有 $y=log _a x(a&gt;0 且 a \neq 1)$)</td></tr><tr><td>log2(x)</td><td>返回底为2的x的对数，x必须大于0</td></tr><tr><td>log10(x)</td><td>返回x的常用对数(底为10)，x必须大于0</td></tr></tbody></table><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><ul><li><p>transpose(M)：返回矩阵M的转置矩阵，如果M是AxB矩阵，则M的转置矩阵是BxA矩阵，其第一列是M的第一行，第二列是M的第二列，第三列是M的第三行，等等。</p></li><li><p>mul(M,N)：矩阵M和矩阵N的矩阵积，如果M的大小为AxB，而N的大小为BxC，则返回一个大小为AxC的矩阵。</p></li></ul>$$mul(M,N)=  \begin{bmatrix}  M_{11} & M_{21} & M_{31} & M_{41} \\  M_{12} & M_{22} & M_{32} & M_{42} \\  M_{13} & M_{23} & M_{33} & M_{43} \\  M_{14} & M_{24} & M_{34} & M_{44} \\  \end{bmatrix}  \begin{bmatrix}  M_{11} & M_{21} & M_{31} & M_{41} \\  M_{12} & M_{22} & M_{32} & M_{42} \\  M_{13} & M_{23} & M_{33} & M_{43} \\  M_{14} & M_{24} & M_{34} & M_{44} \\  \end{bmatrix}$$<ul><li>mul(M,v)：矩阵M和向量v的乘积，如果M是AxB矩阵，v是Bx1向量，则返回Ax1向量。</li></ul>$$mul(M,v)=  \begin{bmatrix}  M_{11} & M_{21} & M_{31} & M_{41} \\  M_{12} & M_{22} & M_{32} & M_{42} \\  M_{13} & M_{23} & M_{33} & M_{43} \\  M_{14} & M_{24} & M_{34} & M_{44} \\  \end{bmatrix}  \begin{bmatrix}  v_{1} \\  v_{2} \\  v_{3} \\  v_{4} \\  \end{bmatrix}$$<ul><li>mul(v,M)：行向量v和矩阵M的乘积，如果v是1xA向量，M是AxB矩阵，则返回1xB向量。</li></ul>$$mul(v,M)=  \begin{bmatrix}  v_{1} & v_{2} & v_{3} & v_{4} \\  \end{bmatrix}  \begin{bmatrix}  M_{11} & M_{21} & M_{31} & M_{41} \\  M_{12} & M_{22} & M_{32} & M_{42} \\  M_{13} & M_{23} & M_{33} & M_{43} \\  M_{14} & M_{24} & M_{34} & M_{44} \\  \end{bmatrix}$$<h2 id="几何函数"><a href="#几何函数" class="headerlink" title="几何函数"></a>几何函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>distance(point1,point2)</td><td>计算点point1与点point2之间的欧几里德距离</td></tr><tr><td>faceforward(N,I,Ng)</td><td>如果dot(Ng,I)&lt;0则返回N，否则返回-N</td></tr><tr><td>length(v)</td><td>返回向量v的长度</td></tr><tr><td>normalize(v)</td><td>对向量v进行归一化，仅保留方向</td></tr><tr><td>reflect(I,N)</td><td>由进入射线方向I和表面法线N计算反射矢量 (仅对三维向量有效)</td></tr><tr><td>refract(I,N,eta)</td><td>给定入射线方向I、法线N和折射系数eta，计算折射矢量；如果I和N之间的角度对于给定的eta来说太大，则返回(0,0,0) (仅对三维向量有效，折射系数：一般定值，可直接通过搜索获取对应数据表)</td></tr></tbody></table><h2 id="纹理相关函数"><a href="#纹理相关函数" class="headerlink" title="纹理相关函数"></a>纹理相关函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>tex2D(sampler2D tex,float2 uv)</td><td>二维纹理查询</td></tr><tr><td>tex2D(sampler2D tex,float2 s,float2 dsdx,float2 dsdy)</td><td>二维纹理查询，带导数，有点糊</td></tr><tr><td>tex2D(sampler2D tex,float3 sz)</td><td>二维纹理查询，带深度，普通图片没效果</td></tr><tr><td>tex2D(sampler2D tex,float3 sz,float2 dsdx ,float2 dsdy)</td><td>二维纹理查询，带导数，带深度</td></tr><tr><td>tex2Dproj(sampler2D tex , float4 szq)</td><td>二维投影纹理查询，跟tex2D差不多，只是会在对纹理采样前除以w分量 (例如GrabPass测试，Unity中tex2D(_MyGrabTexture,i.uv)与tex2Dproj(_MyGrab,float4(i.uv,0,1))结果表现是一致的)</td></tr><tr><td>tex3D(sampler3D tex,float3 s)</td><td>三维纹理查询 <a href="https://docs.unity.cn/2019.4/Documentation/Manual/class-Texture3D.html">示例</a></td></tr><tr><td>tex3D(sampler3D tex,float3 s,float3 dsdx,float3 dsdy)</td><td>三维纹理查询，带导数</td></tr><tr><td>texCUBE(samplerCUBE tex,float3 s)</td><td>立方体纹理查询</td></tr><tr><td>texCUBE(samplerCUBE tex,float3 s,float3 dsdx,float3 dsdy)</td><td>立方体纹理查询，带导数</td></tr></tbody></table><h2 id="导数函数"><a href="#导数函数" class="headerlink" title="导数函数"></a>导数函数</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>ddx(a)</td><td>返回指定值相对于屏幕空间x坐标的偏导数</td></tr><tr><td>ddy(a)</td><td>返回指定值相对于屏幕空间y坐标的偏导数</td></tr></tbody></table><h2 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h2><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>discard</td><td>片元程序使用，丢弃当前像素（会导致Early-Z无效）</td></tr><tr><td>clip(a)</td><td>片元程序使用，若a小于0则丢弃当前像素（会导致Early-Z无效）</td></tr><tr><td>noise</td><td>无效，不过noise可通过float noise = frac(sin(dot(v.uv.xy, float2(12.9898, 78.233))) * 43758.5453)进行trick</td></tr></tbody></table><hr><p>参考文档：<a href="https://developer.download.nvidia.cn/CgTutorial/cg_tutorial_appendix_e.html">CgTutorial</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Shader内置函数记录，特指可在Unity3D中使用的，且个人测试使用过的。&lt;/p&gt;
&lt;h2 id=&quot;数学函数&quot;&gt;&lt;a href=&quot;#数学函数&quot; class=&quot;headerlink&quot; title=&quot;数学函数&quot;&gt;&lt;/a&gt;数学函数&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;t</summary>
      
    
    
    
    <category term="Shader" scheme="https://cwhisme.ml/categories/Shader/"/>
    
    
    <category term="Shader" scheme="https://cwhisme.ml/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D Sahder 关键字</title>
    <link href="https://cwhisme.ml/2021/01/26/Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://cwhisme.ml/2021/01/26/Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-01-25T16:00:00.000Z</published>
    <updated>2021-06-10T10:07:31.475Z</updated>
    
    <content type="html"><![CDATA[<p>用于记录Unity3D的Shader关键字、或内置函数、变量等，便于查询，视情况修改。</p><h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><p>[Attribute]_Name (“Display Name”,Type) = Default Value</p><h3 id="类型-Type"><a href="#类型-Type" class="headerlink" title="类型(Type)"></a>类型(Type)</h3><ul><li>Color 颜色</li><li>Int 整数</li><li>Float、[Range(Min,Max)] 浮点数</li><li>Vector 四维向量</li><li>2D 纹理（默认值：white、black、grey、bump）</li><li>3D 纹理</li><li>Cube 立方体纹理</li></ul><h3 id="属性-Attribute）"><a href="#属性-Attribute）" class="headerlink" title="属性(Attribute）"></a>属性(Attribute）</h3><ul><li>HDR：用于Color类型，将颜色取色器设置为支持HDR类型</li><li>PowerSlider(Value)：用于Int或Float类型，调整材质面板上滑杆拉动效果，对拉动值区间微调</li><li>IntRange：当标记给Range(Min,Max)类型时，会导致材质面板只能拖动整数值</li><li>Toggle：开关，用于Int或Float类型，0代表关，1代表开</li><li>Enum(C#中的枚举类型)：枚举，用于Int或Float类型</li><li>NoScaleOffset：用于纹理类型，取消面板Tiling 、Offset 的设置选项</li><li>Normal：用于2D纹理类型，标记图片必须为法线贴图</li><li>HideInInspector：在面板隐藏</li><li>MainTexture： 表示一个属性 (property) 是材质的主纹理。默认情况下，Unity 将属性 (property) 名称为 _MainTex 的纹理视为主纹理。</li><li>MainColor：表示一个属性 (property) 是材质的主色。默认情况下，Unity 将属性 (property) 名称为 _Color 的颜色视为主色。</li><li>Gamma：用于Float 或 Vector，因为：如果是普通的 Color 属性，使用线性颜色空间时，所有材质颜色属性均以 sRGB 颜色提供，但在传递到着色器时会转换为线性值，该标记会使得Float 或 Vector也进行颜色空间转换。</li></ul><h3 id="纹理特殊说明"><a href="#纹理特殊说明" class="headerlink" title="纹理特殊说明"></a>纹理特殊说明</h3><h4 id="纹理平铺和偏移"><a href="#纹理平铺和偏移" class="headerlink" title="纹理平铺和偏移"></a>纹理平铺和偏移</h4><p>材质通常具有其纹理属性的 Tiling 和 Offset 字段。此信息将传递到着色器中的 float4 {TextureName}_ST 属性：</p><ul><li>x 包含 X 平铺值</li><li>y 包含 Y 平铺值</li><li>z 包含 X 偏移值</li><li>w 包含 Y 偏移值</li></ul><p>例如，如果着色器包含名为 _MainTex 的纹理，则平铺信息将位于 _MainTex_ST 矢量中。</p><h4 id="纹理大小"><a href="#纹理大小" class="headerlink" title="纹理大小"></a>纹理大小</h4><p>{TextureName}_TexelSize - float4 属性包含纹理大小信息：</p><ul><li>x 包含 1.0/宽度</li><li>y 包含 1.0/高度</li><li>z 包含宽度</li><li>w 包含高度</li></ul><h4 id="纹理-HDR-参数"><a href="#纹理-HDR-参数" class="headerlink" title="纹理 HDR 参数"></a>纹理 HDR 参数</h4><p>{TextureName}_HDR - 一个 float4 属性，其中包含有关如何根据所使用的颜色空间解码潜在 HDR（例如 RGBM 编码）纹理的信息。</p><h4 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;TA/NewUnlitShader&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">Properties</span><br><span class="line">&#123;</span><br><span class="line">[HDR]_Color(<span class="string">&quot;Color&quot;</span>,COLOR) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">[IntRange]_Int(<span class="string">&quot;It&#x27;s Int&quot;</span>,Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">_Float(<span class="string">&quot;It&#x27;s Float&quot;</span>,Float) = <span class="number">1</span></span><br><span class="line">_Vector(<span class="string">&quot;It&#x27;s Vector&quot;</span>,Vector)=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">[NoScaleOffset]_Texture2D(<span class="string">&quot;2D Texture&quot;</span>,<span class="number">2</span>D) = <span class="string">&quot;white&quot;</span>&#123;&#125;</span><br><span class="line">[NoScaleOffset]_Texture3D(<span class="string">&quot;3D Texture&quot;</span>,<span class="number">3</span>D) = <span class="string">&quot;&quot;</span>&#123;&#125;</span><br><span class="line">[NoScaleOffset]_TextureCube(<span class="string">&quot;Cube Texture&quot;</span>,Cube) = <span class="string">&quot;&quot;</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">Pass&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Fallback <span class="string">&quot;Diffuse&quot;</span></span><br><span class="line">    CustomEditor <span class="string">&quot;EditorName&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="Shader变量"><a href="#Shader变量" class="headerlink" title="Shader变量"></a>Shader变量</h3><ul><li><p>float：32位浮点数，完整的 float 精度通常用于世界空间位置、纹理坐标或涉及复杂函数（如三角函数或幂/取幂）的标量计算。</p></li><li><p>half：16位浮点数，范围为 –60000 至 +60000，精度约为 3 位小数；一般用于短矢量、方向、对象空间位置、高动态范围颜色。</p></li><li><p>fixed：11位定点数，范围从 –2.0 到 +2.0，精度为 1/256；一般用于常规颜色（通常存储在常规纹理中）以及对它们执行简单运算。</p></li><li><p>int：32位整型；通常用作循环计数器或数组索引。</p></li><li><p>float4、float4x4：复合矢量/矩阵类型(half亦同)</p></li><li><p>sampler2D、sampler3D、samplerCUBE：纹理使用(亦有 sampler2D_half、sampler2D_float)<br>  若使用默认纹理，在移动平台纹理会被自动转换成低精度的纹理类型，如果需要半精度的或者高精度的便需要用以下方式来声明：</p><p>  sampler2D_half、<br>  sampler2D_float、<br>  sampler3D_half、<br>  sampler3D_float、<br>  samplerCUBE_halft、<br>  samplerCUBE_float</p></li></ul><p>一般的经验法则是全部都从半精度开始（但位置和纹理坐标除外）。仅当半精度对于计算的某些部分不足时，才增加精度。</p><h3 id="向顶点程序提供的顶点数据"><a href="#向顶点程序提供的顶点数据" class="headerlink" title="向顶点程序提供的顶点数据"></a>向顶点程序提供的顶点数据</h3><ul><li>POSITION 是顶点位置，通常为 float3 或 float4。</li><li>NORMAL 是顶点法线，通常为 float3。</li><li>TEXCOORD0 是第一个 UV 坐标，通常为 float2、float3 或 float4。</li><li>TEXCOORD1、TEXCOORD2 和 TEXCOORD3 分别是第 2、第 3 和第 4 个 UV 坐标。</li><li>TANGENT 是切线矢量（用于法线贴图），通常为 float4。</li><li>COLOR 顶点颜色，通常为 float4。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata_full</span> &#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float4 tangent : TANGENT;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">    float4 texcoord : TEXCOORD0;</span><br><span class="line">    float4 texcoord1 : TEXCOORD1;</span><br><span class="line">    float4 texcoord2 : TEXCOORD2;</span><br><span class="line">    float4 texcoord3 : TEXCOORD3;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">    UNITY_VERTEX_INPUT_INSTANCE_ID</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若如下所示 引用 了UnityCG.cginc，则具有四个Unity3D预定义的结构体：</p><ul><li>appdata_base： vertex, normal,  texcoord.</li><li>appdata_tan： vertex, tangent, normal,  texcoord.</li><li>appdata_full： vertex, tangent, normal, texcoord, texcoord1, texcoord2, texcoord3, color.</li><li>appdata_img:  vertex, texcoord.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CGPROGRAM</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">ENDCG</span><br></pre></td></tr></table></figure><h3 id="标签（SubShader-Tags）"><a href="#标签（SubShader-Tags）" class="headerlink" title="标签（SubShader Tags）"></a>标签（SubShader Tags）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ex: Tags &#123; &quot;TagName1&quot; = &quot;Value1&quot; &quot;TagName2&quot; = &quot;Value2&quot; &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>参数</th></tr></thead><tbody><tr><td>Queue</td><td>预定义:Background(1000)、Geometry(2000)、AlphaTest(2450)、Transparent(3000)、Overlay(4000)；亦可选择直接填写数值，或类似 『Geometry+500』</td></tr><tr><td>RenderType</td><td>使用替换的着色器进行渲染，脚本可使用函数 Camera.RenderWithShader 或 Camera.SetReplacementShader 来实现着色器替换(ResetReplacementShader重置，有同标签shader物体则替换渲染，无的物体则不再被渲染)。</td></tr><tr><td>DisableBatching</td><td>“true” or “false” ，是否禁用批处理；or “LODFading”(当 LOD 淡化处于激活状态时禁用批处理；主要用于树)</td></tr><tr><td>ForceNoShadowCasting</td><td>“true” or “false”，该子着色器渲染的对象是否投射阴影</td></tr><tr><td>IgnoreProjector</td><td>若值为“True”，则使用此着色器的对象不会受到投影器(Projector[Unity组件])的影响。</td></tr><tr><td>PreviewType</td><td>指示材质检视面板预览应如何显示材质。默认情况下，材质显示为球体，但也可以将 PreviewType 设置为“Plane”（将显示为 2D）或“Skybox”（将显示为天空盒）。</td></tr><tr><td>CanUseSpriteAtlas</td><td>如果着色器用于精灵，请将 CanUseSpriteAtlas 标签设置为“False”，这样在精灵打包到图集内时，该标签将不起作用。</td></tr></tbody></table><h3 id="渲染状态设置"><a href="#渲染状态设置" class="headerlink" title="渲染状态设置"></a>渲染状态设置</h3><h4 id="Cull"><a href="#Cull" class="headerlink" title="Cull"></a>Cull</h4><p><code>Cull Back | Front | Off</code> 设置多边形剔除模式。</p><h4 id="ZTest"><a href="#ZTest" class="headerlink" title="ZTest"></a>ZTest</h4><p><code>ZTest (Less | Greater | LEqual | GEqual | Equal | NotEqual | Always)</code> 设置深度缓冲区测试模式。默认值为 _LEqual_（将前方或远处的对象作为现有对象绘制；隐藏其后面的对象）。</p><h4 id="ZWrite"><a href="#ZWrite" class="headerlink" title="ZWrite"></a>ZWrite</h4><p><code> ZWrite On | Off</code> 设置深度缓冲区写入模式（默认值为 _On_）。</p><h4 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h4><p><code>Offset Factor, Units</code> 设置 Z 缓冲区深度偏移。允许使用两个参数指定深度偏移：<em>factor</em> 和 units。Factor 相对于多边形的 X 或 Y 缩放最大 Z 斜率，而 units 缩放最小可分辨深度缓冲区值。因此可强制将一个多边形绘制在另一个多边形上，尽管它们实际上位于相同位置。例如，Offset 0, -1 将多边形拉近摄像机并忽略多边形的斜率，而 Offset -1, -1 在观察掠射角时进一步拉近多边形。</p><h4 id="ColorMask"><a href="#ColorMask" class="headerlink" title="ColorMask"></a>ColorMask</h4><p><code>ColorMask RGB | A | 0 | R、G、B、A 的任意组合</code> 设置颜色通道写入遮罩。</p><h4 id="混合（Blend）"><a href="#混合（Blend）" class="headerlink" title="混合（Blend）"></a>混合（Blend）</h4><p>设置 Alpha 混合、Alpha 操作和 alpha-to-coverage 模式。</p><h5 id="混合运算"><a href="#混合运算" class="headerlink" title="混合运算"></a>混合运算</h5><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>Add</td><td>将源和目标相加。</td></tr><tr><td>Sub</td><td>从源减去目标。</td></tr><tr><td>RevSub</td><td>从目标减去源。</td></tr><tr><td>Min</td><td>使用源和目标中的较小者。</td></tr><tr><td>Max</td><td>使用源和目标中的较大者。</td></tr></tbody></table><h5 id="混合系数"><a href="#混合系数" class="headerlink" title="混合系数"></a>混合系数</h5><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>One</td><td>值为 1 - 让源或目标颜色通过。</td></tr><tr><td>Zero</td><td>值为 0 - 删除源或目标值。</td></tr><tr><td>SrcColor</td><td>此阶段的值乘以源颜色值。</td></tr><tr><td>SrcAlpha</td><td>此阶段的值乘以源 Alpha 值。</td></tr><tr><td>DstColor</td><td>此阶段的值乘以帧缓冲区源颜色值。</td></tr><tr><td>DstAlpha</td><td>此阶段的值乘以帧缓冲区源 Alpha 值。</td></tr><tr><td>OneMinusSrcColor</td><td>此阶段的值乘以（1 - 源颜色）。</td></tr><tr><td>OneMinusSrcAlpha</td><td>此阶段的值乘以（1 - 源 Alpha）。</td></tr><tr><td>OneMinusDstColor</td><td>此阶段的值乘以（1 - 目标颜色）。</td></tr><tr><td>OneMinusDstAlpha</td><td>此阶段的值乘以（1 - 目标 Alpha）。</td></tr></tbody></table><h5 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha // 传统透明度</span><br><span class="line">Blend One OneMinusSrcAlpha // 预乘透明度</span><br><span class="line">Blend One One // 加法</span><br><span class="line">Blend OneMinusDstColor One // 软加法</span><br><span class="line">Blend DstColor Zero // 乘法</span><br><span class="line">Blend DstColor SrcColor // 2x 乘法</span><br></pre></td></tr></table></figure><h3 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h3><ul><li>SV_POSITION：顶点着色器输出顶点的最终裁剪空间位置</li><li>SV_Target：片段着色器输出语义（SV_TargetN[SV_Target1、SV_Target2等]）</li><li>SV_Depth：片段着色器深度输出</li><li>VPOS：(UNITY_VPOS_TYPE)屏幕空间像素位置。[需求#pragma target 3.0]</li><li>VFACE：正面的 VFACE 输入为正，背面的为负。[需求#pragma target 3.0]</li><li>SV_VertexID：(uint)顶点 ID [需求#pragma target 3.5]</li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><h3 id="UnityCG-cginc"><a href="#UnityCG-cginc" class="headerlink" title="UnityCG.cginc"></a>UnityCG.cginc</h3><h4 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h4><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>float4 UnityObjectToClipPos(float3 pos)</td><td>将对象空间中的点变换到齐次坐标中的摄像机裁剪空间。这等效于 mul(UNITY_MATRIX_MVP, float4(pos, 1.0))，应该在适当的位置使用</td></tr><tr><td>float3 UnityObjectToViewPos(float3 pos)</td><td>将对象空间中的点变换到视图空间。这等效于 __mul(UNITY_MATRIX_MV, float4(pos, 1.0)).xyz__，应该在适当的位置使用</td></tr><tr><td>float3 WorldSpaceViewDir(float4 v)</td><td>返回从给定对象空间顶点位置朝向摄像机的世界空间方向（未标准化）</td></tr><tr><td>float3 ObjSpaceViewDir(float4 v)</td><td>返回从给定对象空间顶点位置朝向摄像机的对象空间方向（未标准化）</td></tr><tr><td>float2 ParallaxOffset(half h, half height, half3 viewDir)</td><td>计算视差法线贴图的 UV 偏移</td></tr><tr><td>fixed Luminance(fixed3 c)</td><td>将颜色转换为亮度（灰阶）</td></tr><tr><td>fixed3 DecodeLightmap(fixed4 color)</td><td>从 Unity 光照贴图（RGBM 或 dLDR，具体取决于平台）解码颜色</td></tr><tr><td>float4 EncodeFloatRGBA(float v)</td><td>将 [0..1) 范围浮点数编码为 RGBA 颜色，用于存储在低精度渲染目标中</td></tr><tr><td>float DecodeFloatRGBA(float4 enc)</td><td>将 RGBA 颜色解码为浮点数</td></tr><tr><td>float2 EncodeFloatRG(float v)</td><td>将 [0..1) 范围浮点数编码为 float2</td></tr><tr><td>float DecodeFloatRG(float2 enc)</td><td>解码先前编码的 RG 浮点数</td></tr><tr><td>float2 EncodeViewNormalStereo(float3 n)</td><td>将视图空间法线编码为 0 到 1 范围内的两个数字</td></tr><tr><td>float3 DecodeViewNormalStereo(float4 enc4)</td><td>从 enc4.xy 解码视图空间法线</td></tr><tr><td>float4 ComputeScreenPos(float4 clipPos)</td><td>计算用于执行屏幕空间贴图纹理采样的纹理坐标。输入是裁剪空间位置</td></tr><tr><td>float4 ComputeGrabScreenPos(float4 clipPos)</td><td>计算用于 GrabPass 纹理采样的纹理坐标。输入是裁剪空间位置</td></tr><tr><td>float3 UnityWorldSpaceViewDir(float3 worldPos)</td><td>给定世界坐标，计算视线方向向量，返回值并未归一化</td></tr><tr><td>float3 WorldSpaceViewDir(float4 localPos)</td><td>给定物体空间坐标，计算视线方向向量，返回值并未归一化</td></tr><tr><td>float3 UnityObjectToWorldNormal(float3 norm)</td><td>将法线从物体空间变换至世界空间</td></tr></tbody></table><h4 id="特定渲染下的辅助函数"><a href="#特定渲染下的辅助函数" class="headerlink" title="特定渲染下的辅助函数"></a>特定渲染下的辅助函数</h4><p>仅当使用前向渲染（ForwardBase 或 ForwardAdd 通道类型）时，这些函数才有用。</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>float3 WorldSpaceLightDir(float4 v)</td><td>根据给定的对象空间顶点位置计算朝向光源的世界空间方向（未标准化）。</td></tr><tr><td>float3 ObjSpaceLightDir(float4 v)</td><td>根据给定对象空间顶点位置计算朝向光源的对象空间方向（未标准化）。</td></tr><tr><td>float3 Shade4PointLights(…)</td><td>计算四个点光源的光照，将光源数据紧密打包到矢量中。前向渲染使用它来计算每顶点光照。</td></tr></tbody></table><p>仅当使用每顶点光照着色器（“Vertex”通道类型）时，这些函数才有用。</p><p>|函数|说明|<br>float3 ShadeVertexLights(float4 vertex, float3 normal)|根据给定的对象空间位置和法线计算四个每顶点光源和环境光的光照。</p><h2 id="内置着色器变量"><a href="#内置着色器变量" class="headerlink" title="内置着色器变量"></a>内置着色器变量</h2><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>UNITY_MATRIX_MVP</td><td>当前模型 * 视图 * 投影矩阵。</td></tr><tr><td>UNITY_MATRIX_MV</td><td>当前模型 * 视图矩阵。</td></tr><tr><td>UNITY_MATRIX_V</td><td>当前视图矩阵。</td></tr><tr><td>UNITY_MATRIX_P</td><td>当前投影矩阵。</td></tr><tr><td>UNITY_MATRIX_VP</td><td>当前视图 * 投影矩阵。</td></tr><tr><td>UNITY_MATRIX_T_MV</td><td>模型转置 * 视图矩阵。</td></tr><tr><td>UNITY_MATRIX_IT_MV</td><td>模型逆转置 * 视图矩阵。用于将法线从模型转换至相机空间。</td></tr><tr><td>unity_ObjectToWorld</td><td>当前模型矩阵。</td></tr><tr><td>unity_WorldToObject</td><td>当前世界矩阵的逆矩阵。</td></tr></tbody></table><h3 id="摄像机和屏幕"><a href="#摄像机和屏幕" class="headerlink" title="摄像机和屏幕"></a>摄像机和屏幕</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_WorldSpaceCameraPos</td><td>float3</td><td>摄像机的世界空间位置。</td></tr><tr><td>_ProjectionParams</td><td>float4</td><td>x 是 1.0（如果当前使用翻转投影矩阵进行渲染，则为 –1.0），y 是摄像机的近平面，z 是摄像机的远平面，w 是远平面的倒数。</td></tr><tr><td>_ScreenParams</td><td>float4</td><td>x 是摄像机目标纹理的宽度（以像素为单位），y 是摄像机目标纹理的高度（以像素为单位），z 是 1.0 + 1.0/宽度，w 为 1.0 + 1.0/高度。</td></tr><tr><td>_ZBufferParams</td><td>float4</td><td>用于线性化 Z 缓冲区值。x 是 (1-远/近)，y 是 (远/近)，z 是 (x/远)，w 是 (y/远)。</td></tr><tr><td>unity_OrthoParams</td><td>float4</td><td>x 是正交摄像机的宽度，y 是正交摄像机的高度，z 未使用，w 在摄像机为正交模式时是 1.0，而在摄像机为透视模式时是 0.0。</td></tr><tr><td>unity_CameraProjection</td><td>float4x4</td><td>摄像机的投影矩阵。</td></tr><tr><td>unity_CameraInvProjection</td><td>float4x4</td><td>摄像机投影矩阵的逆矩阵。</td></tr><tr><td>unity_CameraWorldClipPlanes[6]</td><td>float4</td><td>摄像机视锥体平面世界空间方程，按以下顺序：左、右、底、顶、近、远。</td></tr></tbody></table><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_Time</td><td>float4</td><td>自关卡加载以来的时间 (t/20, t, t<em>2, t</em>3)，用于将着色器中的内容动画化。</td></tr><tr><td>_SinTime</td><td>float4</td><td>时间正弦：(t/8, t/4, t/2, t)。</td></tr><tr><td>_CosTime</td><td>float4</td><td>时间余弦：(t/8, t/4, t/2, t)。</td></tr><tr><td>unity_DeltaTime</td><td>float4</td><td>增量时间：(dt, 1/dt, smoothDt, 1/smoothDt)。</td></tr></tbody></table><h3 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h3><p>前向渲染（ForwardBase 和 ForwardAdd 通道类型）：</p><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>_LightColor0</td><td>fixed4</td><td>光源颜色（在 UnityLightingCommon.cginc 中声明）。</td></tr><tr><td>_WorldSpaceLightPos0</td><td>float4</td><td>方向光：（世界空间方向，0）。其他光源：（世界空间位置，1）。</td></tr><tr><td>unity_WorldToLight</td><td>float4x4</td><td>世界/光源矩阵。用于对剪影和衰减纹理进行采样（在 AutoLight.cginc 中声明）。</td></tr><tr><td>unity_4LightPosX0、unity_4LightPosY0、unity_4LightPosZ0</td><td>float4</td><td>（仅限 ForwardBase 通道）前四个非重要点光源的世界空间位置。</td></tr><tr><td>unity_4LightAtten0</td><td>float4</td><td>（仅限 ForwardBase 通道）前四个非重要点光源的衰减因子。</td></tr><tr><td>unity_LightColor</td><td>half4[4]</td><td>（仅限 ForwardBase 通道）前四个非重要点光源的颜色。</td></tr><tr><td>unity_WorldToShadow</td><td>float4x4[4]</td><td>世界/阴影矩阵。聚光灯的一个矩阵，方向光级联最多有四个矩阵。</td></tr></tbody></table><h3 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h3><table><thead><tr><th>名称</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>unity_Lightmap</td><td>Texture2D</td><td>包含光照贴图信息。</td></tr><tr><td>unity_LightmapST</td><td>float4[8]</td><td>缩放 UV 信息并转换到正确的范围以对光照贴图纹理进行采样。</td></tr></tbody></table><h3 id="雾效和环境光"><a href="#雾效和环境光" class="headerlink" title="雾效和环境光"></a>雾效和环境光</h3><p>unity_AmbientSky|    fixed4|    梯度环境光照情况下的天空环境光照颜色。<br>unity_AmbientEquator|    fixed4|    梯度环境光照情况下的赤道环境光照颜色。<br>unity_AmbientGround|    fixed4|    梯度环境光照情况下的地面环境光照颜色。<br>UNITY_LIGHTMODEL_AMBIENT|    fixed4|    环境光照颜色（梯度环境情况下的天空颜色）。旧版变量。<br>unity_FogColor|    fixed4|    雾效颜色。<br>unity_FogParams|    float4|    用于雾效计算的参数：(density / sqrt(ln(2))、density / ln(2)、–1/(end-start) 和 end/(end-start))。x 对于 Exp2 雾模式很有用；<em>y</em> 对于 Exp 模式很有用，<em>z</em> 和 w 对于 Linear 模式很有用。</p><h2 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h2><h3 id="GrabPass"><a href="#GrabPass" class="headerlink" title="GrabPass"></a>GrabPass</h3><p>一般以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GrabPass &#123; &quot;TextureName&quot; &#125; </span><br><span class="line">sampler2D TextureName</span><br></pre></td></tr></table></figure><h3 id="摄像机的深度纹理"><a href="#摄像机的深度纹理" class="headerlink" title="摄像机的深度纹理"></a>摄像机的深度纹理</h3><p>通过声明 sampler2D _CameraDepthTexture 可直接引用；非线性值，存在x中，范围 [0,1]</p><p>(注：另外还有 _LastCameraDepthTexture  纹理)</p><p>可使用帮助函数：</p><p>名|说明<br>Linear01Depth(i)|通过深度纹理 i 给出高精度值时，返回相应的线性深度，范围在 0 到 1 之间<br>LinearEyeDepth(i)|通过深度纹理 i 计算，返回相应的视空间线性深度<br>COMPUTE_EYEDEPTH(float3 o)|顶点函数中使用，返回当前顶点视空间深度，一般用于不会被记录深度值的透明物体自身</p><ul><li>获取当前物体当前深度：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vert：COMPUTE_EYEDEPTH(o.screenPos.z);<span class="comment">//返回的为该物体处于视空间的深度值</span></span><br><span class="line">frag：fixed depth=LinearEyeDepth(tex2Dproj(_CameraDepthTexture,i.screenPos))<span class="comment">//获取该片元之前位于视空间的深度值，并将其转化为线性值</span></span><br></pre></td></tr></table></figure><p> 若通过 <code>depth.x-(i.screenPos.z)</code> 直接返回为颜色值，则会有如图结果：</p><p> <img src="/blogimages/2021/2021-01-26-Unity3DSahder%E5%85%B3%E9%94%AE%E5%AD%97.png" alt="地形混合贴图"></p><p><font color=red>注：仅“不透明”对象（这些对象的材质和着色器设置为使用小于等于 2500 的渲染队列）会自动被渲染到深度纹理中</font></p><h3 id="透明物体"><a href="#透明物体" class="headerlink" title="透明物体"></a>透明物体</h3><p>分为 透明度测试(无效像素直接丢弃)、 透明度混合两类。<br>需要着重注意渲染顺序问题，Queue 标签对队列进行标识</p><p>若使用透明度混合，为解决透明物体渲染问题，可使用一个Pass开启深度测试，第二个Pass进行正常处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Tags &#123;&quot;Queue&quot;=&quot;Transparent&quot; &quot;RenderType&quot;=&quot;Transparent&quot;&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">ZWrite On</span><br><span class="line">ColorMask 0</span><br><span class="line">&#125;</span><br><span class="line">Pass&#123;</span><br><span class="line">ZWrite Off</span><br><span class="line">Cull Off</span><br><span class="line">Blend XXX XXX</span><br><span class="line">//TODO:...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于此详细可参考 <a href="https://dragon_boy.gitee.io/2020/06/20/UnityShaderAlpha/">Dragons blog：Unity Shader:透明效果</a></p><h3 id="UsePass"><a href="#UsePass" class="headerlink" title="UsePass"></a>UsePass</h3><p>复用指定Shader的Pass：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UsePass &quot;Shader/NAME&quot;</span><br></pre></td></tr></table></figure><blockquote><p>注：指定Shader的Pass需使用 <code>Name &quot;MyPassName&quot;</code> 命名，且在内部，所有通道名称均大写，因此 UsePass 必须引用大写名称。</p></blockquote><hr><blockquote><p>注:测试环境为Unity3D 2019.2.4f1<br>参考:</p><ul><li><a href="https://www.zhihu.com/column/unityTA">知乎专栏</a> </li><li><a href="https://docs.unity.cn/2019.4/Documentation/Manual/SL-DataTypesAndPrecision.html">Unity3D官方文档</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用于记录Unity3D的Shader关键字、或内置函数、变量等，便于查询，视情况修改。&lt;/p&gt;
&lt;h2 id=&quot;Properties&quot;&gt;&lt;a href=&quot;#Properties&quot; class=&quot;headerlink&quot; title=&quot;Properties&quot;&gt;&lt;/a&gt;Prope</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/categories/Unity3D/"/>
    
    
    <category term="Shader" scheme="https://cwhisme.ml/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>2020年总结+关于此Blog</title>
    <link href="https://cwhisme.ml/2021/01/06/2020%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
    <id>https://cwhisme.ml/2021/01/06/2020%E5%B9%B4%E6%80%BB%E7%BB%93/</id>
    <published>2021-01-05T16:00:00.000Z</published>
    <updated>2021-06-07T02:08:31.568Z</updated>
    
    <content type="html"><![CDATA[<p>旧的一年再次过去了，2020年已经没了。不过本篇肯定不能称之为『照例』了，毕竟博客写作什么的，起码也是停更几年了。不过现在，在决定再次开始写写东西并把新博客搭建完毕后，还是写一下总结罢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天是2021年1月6日 星期三 天气，算阴吧。<br>一直坐在公司，对外面也没什么感觉。</p><p>不觉一年又过去了，前半年疫情，后半年基本上在加班。前几天元旦都是加班加过来的。本来这篇总结打算元旦写一写，一直拖到现在。</p><p>当然，虽然忙，期间也还是研究了些东西的，毕竟虽然一直加班，偶尔也是有“加剩”的时间的。<br>虽然都是从项目相关开始延伸出来的，比如CrySimpleNet，一个简单的网络框架、文件对比对比工具等等。以后有时间了或许会写一写相关文章，嗯…大概。</p><p>本博客托管于Gitpages，使用jekyll构建。也是在这次2020年快过去，有点时间之后，一点点搞出来的。<br>例如解决这个博客模板的编译错误、修改博客模板适用自己等等。反正到现在可以使用为止，还是着实折腾了一番。算是复习了一番css、js、jquery、到处查bootstrap用法等等。<br>最终虽然不算很完美，不过对于个人来说倒也足够了，后续就可以写点东西了。</p><p>另外，还有一堆几年前托管在Coding Page上的博文，也被我挪了过来，那时候使用Hexo搞的，不过所幸归根结底都是markdown格式的文章，所以移植过来倒也费不了太大功夫。<br>毕竟也是段历史了。后续添加了文章『多少天/月/年』的计算显示后，才惊觉最晚的博文，都已经是『6年前』的了？真是时间如水，不经意、还是无知觉中，就完了？</p><p>莫名地甚至有点无所实感…..</p><p>春节之后就是周年庆了，据说会更忙，希望在之后能正常点吧。这样才能有足够的时间提升自己，研究一些新技术之类，而非变成一个无情的拼图仔。</p><h2 id="关于新博客"><a href="#关于新博客" class="headerlink" title="关于新博客"></a>关于新博客</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>说到这个，之前托管到 Coding 的 Hexo 搞的博客，多年未曾更新了，后续更是随着 Coding 托管静态页面政策不断更新，甚至直接给我关闭了。<br>关闭就关闭，索性就不再关注了。</p><p>最近偶然之间，听闻 GitPages，因此生出一些兴趣，又捡了起来。</p><p>当然，GitPages 早在曾经弄Coding托管Blog，Hexo 作框架的时候就已了解，不过当时觉着毕竟属于国外，太慢，便也不喜欢。<br>现在看来，果然还是国外大牌的稳定，国内用过的 Coding、七牛云，如今想要使用，都是越渐麻烦。</p><p>所以这次连图片都直接放在 Git 上了，想使用 jsdeliver 加个速罢。<br>关于jsdeliver加速图片，是参考这个博文：<a href="https://mazhuang.org/2020/10/07/cdn-for-github-pages-2">使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源（二）</a></p><p>PS：刚开始搭 GitPages 其实还想用这个主题来着，后续发现该主题的源主题后，个人觉得源主题 <a href="https://github.com/DONGChuan/Yummy-Jekyll">Yummy Jekyll Theme</a> 好看一点，于是就拉了 Yummy-Jekyll 来修改。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>可惜 Yummy-Jekyll 主题的作者好几年都不再维护了，因此拉下来得解决一些问题。顺便升级了各个插件，比如 Bootstraps 改成了 Bootstraps4 版本，又修改了一些因为升级插件导致排版出现的问题。<br>后续还想把主题所用的octicon替换成最新的 jekyll-octicons，结果全都替换之后，本地倒没问题，上传Git就炸了。</p><p>而且收到的编译错误邮件只有这么些内容：</p><blockquote><p>The page build failed for the <code>main</code> branch with the following error:</p></blockquote><blockquote><p>The tag <code>octicon</code> on line 4 in <code>_includes/header.html</code> is not a recognized Liquid tag. For more information, see <a href="https://docs.github.com/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites#unknown-tag-error">https://docs.github.com/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites#unknown-tag-error</a>.</p></blockquote><p>这就非常难以查错，折腾良久都无果。</p><p>最后使用 还原初始、增量上传的笨办法，一个个对比查找，终于定位到 jekyll-octicons 的问题了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for %&#125;</span><br><span class="line">&#123;% octicon circle %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>比如这种使用方式，在 liquid 模板的 for 循环中是会出问题的！<br>虽然不知道为什么本地可以运行，GItPages的服务器不行，但的确是这个问题没错了。而且查看编译后的页面，可以发现 jekyll-octicons 会被编译成一堆重复 class 诸如 “class=”octicon circle octicon circle octicon circle ……” ” 的格式。</p><p>看着都极不正常。<br>最初还是想修复一下，看有没有解决之法。毕竟使用 jekyll-octicons 一不用在自己项目额外放东西，二不需要作其他引用，应当是编译的时候便已经生成了相应内容了。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>不过，估摸着是使用的人太少，亦或者是太偏门，反正是没找到几个相关信息。<br>最终索性也不管这些第三方的icon插件了，直接自己写了个js代码，用以动态替换指定标记为svg图片。<br>原理很简单，在文档加载完毕后，搜索</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;octicon-mark-github&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种代码，并将其替换为相应标记的图片，甚至图片内容直接写在js文件中，用什么icon添加加什么icon。</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**************************************************</span></span><br><span class="line"><span class="comment"> * SvgIconHolder.js</span></span><br><span class="line"><span class="comment"> * 本来打算是使用jekyll-octicons的，结果发现有bug，特别是在liquid for语句 &#123;% for %&#125; 中使用，GitPage直接build error，而且是没有提示的那种</span></span><br><span class="line"><span class="comment"> * 几经搜索，依然无果。</span></span><br><span class="line"><span class="comment"> * 因此自己写了个折中方法，使用js动态替换</span></span><br><span class="line"><span class="comment"> * octiconsDic 为key与对应对应的svg数据</span></span><br><span class="line"><span class="comment"> * author:CWHISME</span></span><br><span class="line"><span class="comment"> * git:https://github.com/CWHISME</span></span><br><span class="line"><span class="comment"> * 2020.12.28</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">var</span> octiconsDic = &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> octiconsDic) &#123;</span><br><span class="line">        <span class="keyword">var</span> target = $(<span class="string">&quot;span#&quot;</span> + key);</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">var</span> defaultWidth = defaultHeight = <span class="number">16</span>;</span><br><span class="line">        target.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> val = $(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">var</span> width = val.attr(<span class="string">&quot;width&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> height = val.attr(<span class="string">&quot;height&quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> style = val.attr(<span class="string">&quot;style&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (width == <span class="literal">null</span>)</span><br><span class="line">                width = defaultWidth;</span><br><span class="line">            <span class="keyword">if</span> (height == <span class="literal">null</span>)</span><br><span class="line">                height = defaultHeight;</span><br><span class="line">            <span class="keyword">if</span> (style == <span class="literal">null</span>)</span><br><span class="line">                style = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">var</span> resultHtml = <span class="string">&#x27;&lt;svg class=&quot;octicon &#x27;</span>.concat(key, <span class="string">&#x27;&quot; viewBox=&quot;0 0 &#x27;</span>, <span class="number">16</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">16</span>, <span class="string">&#x27;&quot; version=&quot;1.1&quot; width=&quot;&#x27;</span>, width, <span class="string">&#x27;&quot; height=&quot;&#x27;</span>, height, <span class="string">&#x27;&quot; aria-hidden=&quot;true&quot; style=&quot;\</span></span><br><span class="line"><span class="string">fill: currentColor;\</span></span><br><span class="line"><span class="string">vertical-align: center;\</span></span><br><span class="line"><span class="string">&#x27;</span>, style, <span class="string">&#x27;&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;&#x27;</span>, octiconsDic[key], <span class="string">&#x27;&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&#x27;</span>);</span><br><span class="line">            val.replaceWith(resultHtml);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外，还加了一些其他古怪效果，比如404、右键单击图片加彩蛋，嗯..等？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;旧的一年再次过去了，2020年已经没了。不过本篇肯定不能称之为『照例』了，毕竟博客写作什么的，起码也是停更几年了。不过现在，在决定再次开始写写东西并把新博客搭建完毕后，还是写一下总结罢。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;header</summary>
      
    
    
    
    <category term="总结" scheme="https://cwhisme.ml/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>UE4水龙头流水效果</title>
    <link href="https://cwhisme.ml/2017/05/17/2017-5-17-UE4-Water-Tap-Effect/"/>
    <id>https://cwhisme.ml/2017/05/17/2017-5-17-UE4-Water-Tap-Effect/</id>
    <published>2017-05-17T13:05:20.000Z</published>
    <updated>2021-05-10T02:57:25.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些日子做了个水龙头流水的效果（当然跟高大上的流体之类的无关），所用到的无非就是粒子效果+Shader+部分代码而已。<br>不过，自己觉得看着还行，所以有此一记。</p><p>效果如下：</p><raw><iframe height=498 width=710 src="https://player.youku.com/embed/XMjc3MDMxMjQ0MA==" frameborder=0 allowfullscreen> </iframe></raw><p>简答来说，就是开启水龙头-&gt;流水，同时扰动水纹，关闭水龙头-&gt;关闭水，同时慢慢将水纹渐隐掉。<br>(上面两个手柄是因为：这个是VR项目，开发机跟运行机是不同的，我的开发机上面什么都没，没办法之下只有模拟下了，不过只要接入VR就会自动转换了，没什么影响)</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>先来看看UE4材质节点：</p><p><img src="/blogimages/oldpictures/2017.5.17-Water.png"></p><p><img src="/blogimages/oldpictures/2017.5.17-Water1.png"></p><p><img src="/blogimages/oldpictures/2017.5.17-Water2.png"></p><p><img src="/blogimages/oldpictures/2017.5.17-Water3.png"></p><p><img src="/blogimages/oldpictures/2017.5.17-Water4.png"></p><p>材质实例设置：</p><p><img src="/blogimages/oldpictures/2017.5.17-Water5.png"></p><p>就是这样。</p><p>其中，主要就是通过Sin计算纹理扰动比较麻烦，但若是用代码来描述的话，也就是几句的事情——实际上，在UE4中我拖出这些节点来了之后，自己都看着费劲，所以原本，这个效果我是先行在Unity3D中实现的：</p><p><img src="/blogimages/oldpictures/2017.5.17-WaterWave.gif" alt="水纹效果"></p><p>主要代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">float2 uv = i.uv;</span><br><span class="line">uv -= <span class="built_in">float2</span>(<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">float</span> dis =<span class="built_in">sqrt</span>( <span class="built_in">dot</span>(uv,uv));</span><br><span class="line">uv =i.uv+ <span class="built_in">sin</span>(<span class="number">100</span>*dis - _Time.y*<span class="number">10</span>)*i.uv*<span class="number">0.01</span>*<span class="number">3</span>;</span><br><span class="line">fixed4 col = <span class="built_in">tex2D</span>(_GrabTexture,uv);</span><br></pre></td></tr></table></figure><p>其原理就是首先将UV挪到中心，计算其与中心的距离，然后通过sin函数+时间等参数对UV进行扰动。<br>我这儿时抓取了屏幕纹理（_GrabTexture），所以看着就是这种效果了。</p><p>在UE4中，除此之外，还另外增加了使用发现进行扰动的效果，以及插值“平静水面与扰动水面”的功能。</p><p>代码中开关如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ATriggerWaterTapActor::Tick</span><span class="params">(<span class="keyword">float</span> DeltaTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bCanOpen)</span><br><span class="line">&#123;</span><br><span class="line">WaterWaveValue = FMath::<span class="built_in">Lerp</span>(WaterWaveValue, <span class="number">0.0f</span>, DeltaTime*<span class="number">0.35f</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">WaterWaveValue = FMath::<span class="built_in">Lerp</span>(WaterWaveValue, <span class="number">1.0f</span>, DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">2</span>, <span class="number">3</span>, FColor::Cyan, FString::<span class="built_in">SanitizeFloat</span>(WaterWaveValue));</span><br><span class="line">WaterMesh-&gt;<span class="built_in">SetScalarParameterValueOnMaterials</span>(<span class="built_in">FName</span>(<span class="string">&quot;Wave&quot;</span>), WaterWaveValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ATriggerWaterTapActor::OnTriggered_Implementation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Super::<span class="built_in">OnTriggered_Implementation</span>();</span><br><span class="line"></span><br><span class="line">bCanOpen = !bCanOpen;</span><br><span class="line"><span class="keyword">bool</span> active = bCanOpen;</span><br><span class="line">active ? _particleSystem-&gt;<span class="built_in">Deactivate</span>() : _particleSystem-&gt;<span class="built_in">Activate</span>();</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">1</span>, FColor::Green, active ? <span class="built_in">TEXT</span>(<span class="string">&quot;关闭&quot;</span>) : <span class="built_in">TEXT</span>(<span class="string">&quot;开启&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前些日子做了个水龙头流水的效果（当然跟高大上的流体之类的无关），所用到的无非就是粒子效果+Shader+部分代码而已。&lt;br&gt;不过，自己觉得</summary>
      
    
    
    
    <category term="UE4" scheme="https://cwhisme.ml/categories/UE4/"/>
    
    
    <category term="UE4" scheme="https://cwhisme.ml/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>Unity Kinect 开发</title>
    <link href="https://cwhisme.ml/2017/05/10/2017-5-10-Unity-Kinect/"/>
    <id>https://cwhisme.ml/2017/05/10/2017-5-10-Unity-Kinect/</id>
    <published>2017-05-10T11:43:53.000Z</published>
    <updated>2021-05-10T02:57:25.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>据说，前几天据说公司接到一个委托，可能要做Kinect相关的一些东西：比如小游戏或者其他一些功能之类的。<br>所以，就要用到Kinect了，平台么…自然是Unity3D了。</p><p>曾经我也说过了吧，这个公司Unity3D、UE4、AR、VR、MR…..什么的大约都是要搞的，所以，昨天就研究了下Kinect。</p><h1 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先，公司买的Kinect是v2版本的，百度一下“Kinect V2”看看图片就可明白了：左边一个摄像头模样，右边一个XBOX的图标。<br>还是来张图片吧：</p><p><img src="/blogimages/oldpictures/2017.5.10-1.jpg" alt="Kinect V2"></p><p>首先，老样子。既然要开发，那就得下载SDK了。<br>Kinect 驱动及官方SDK：<a href="https://developer.microsoft.com/zh-cn/windows/kinect">https://developer.microsoft.com/zh-cn/windows/kinect</a></p><p>接着是适用于Unity3D的插件——虽然很多人说是可用AssetStore里边的，不过貌似现在都没更新了。<br>为了谨慎起见，还是用微软官方提供的Unity3D插件吧：<br>Unity Pro 程序包：<a href="https://developer.microsoft.com/zh-cn/windows/kinect/tools">https://developer.microsoft.com/zh-cn/windows/kinect/tools</a></p><p>在这个页面，点击“Unity Pro 程序包”即可下载。<br>如图：</p><p><img src="/blogimages/oldpictures/2017.5.10-2.png"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>东西都下载了，接下来是安装。</p><p>首先，需要说明的一点是：Kinect2.0  的SDK仅支持Win8及以上的系统，所以，若还在使用Win7的话….赶紧换了吧，不然就不要想接下来的事儿了。</p><p>然后，安装之前先把Kinect的从USB接口拔出来，安装完成之后，再插上去。<br>若是没问题，那么插上去的时候，Kinect就会自动安装驱动（如果没有的话，那么请检查下是否插入的是 USB3.0的接口，或者稍稍拔起插下试试，USB连接这儿也会有所影响[在下当时便费了些许功夫调式此处，因为这儿还有可能会造成连接之后，相机Frame无法读取的问题，表现就是运行时，中间的红灯一闪一闪]）。</p><p>完成之后，可于“设备管理器”中查看，如图：</p><p><img src="/blogimages/oldpictures/2017.5.10-3.png"></p><p>为了检验下，这时还可打开“Kinect SDKBrower2.0”，点开Kinect Configuration Verifier，运行，可以检测Kinect相关的详细情形。<br>如图：</p><p><img src="/blogimages/oldpictures/2017.5.10-4.png"></p><p>若是这样，那么安装就已经OK了。</p><h2 id="Unity3D开发测试"><a href="#Unity3D开发测试" class="headerlink" title="Unity3D开发测试"></a>Unity3D开发测试</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>接下来，打开Unity3D，新建项目，导入之前下载的“KinectForWindows_UnityPro_2.0.1410”压缩包中的“Kinect.2.0.1410.19000.unitypackage”。<br>然后将其中的示例KinectView文件夹复制至Assets目录下，便可运行场景进行测试了。</p><p>在此，可以看见一张彩色图像及一张深度图及一个根据深度对彩色图采样的Mesh。</p><p>注意：若是还想看GreenScreen示例的话，直接复制进来，其中自带的一个Shader会报错。<br>这儿可以这样改一下：<br>将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Texture2D _MainTex; </span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNITY_DECLARE_TEX2D(_MainTex);</span><br></pre></td></tr></table></figure><p>后面frag函数中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//o = _MainTex.Sample(SampleType, i.tex);</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o = UNITY_SAMPLE_TEX2D(_MainTex, i.tex);</span><br></pre></td></tr></table></figure><p>即可解决。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>为了测试，我自己写了一个小脚本：功能主要就是实现一个UI，表示右手的位置，握拳，就截取一张图片：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"><span class="keyword">using</span> Windows.Kinect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KinectSensor _sensor;</span><br><span class="line">    <span class="keyword">private</span> Body[] _bodys;</span><br><span class="line">    <span class="keyword">private</span> BodyFrameReader _bodyFrameReader;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HashSet</span>&lt;<span class="title">Body</span>&gt; _bodySet</span> = <span class="keyword">new</span> HashSet&lt;Body&gt;();</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Image _hand;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Sprite _handClosed;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Sprite _handOpen;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Sprite _handUnkown;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 _pos;</span><br><span class="line">    <span class="comment">// Use this for initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _sensor = KinectSensor.GetDefault();</span><br><span class="line">        <span class="keyword">if</span> (!_sensor.IsOpen)</span><br><span class="line">            _sensor.Open();</span><br><span class="line">        <span class="keyword">if</span> (_sensor != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _bodyFrameReader = _sensor.BodyFrameSource.OpenReader();</span><br><span class="line">            _bodys = <span class="keyword">new</span> Body[_bodyFrameReader.BodyFrameSource.BodyCount];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sensor != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> (BodyFrame bodyFrame = _bodyFrameReader.AcquireLatestFrame())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (bodyFrame != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    bodyFrame.GetAndRefreshBodyData(_bodys);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> body <span class="keyword">in</span> _bodys)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (body.IsTracked)</span><br><span class="line">                        &#123;</span><br><span class="line">                            _bodySet.Add(body);</span><br><span class="line"></span><br><span class="line">                            Windows.Kinect.Joint jo = body.Joints[JointType.HandRight];</span><br><span class="line">                            <span class="keyword">if</span> (jo.TrackingState != TrackingState.NotTracked)</span><br><span class="line">                            &#123;</span><br><span class="line">                                _pos = <span class="keyword">new</span> Vector3(jo.Position.X, jo.Position.Y, jo.Position.Z);</span><br><span class="line"></span><br><span class="line">                                _hand.transform.position = <span class="keyword">new</span> Vector3((jo.Position.X + <span class="number">1</span>) / <span class="number">2</span> * Screen.width, (jo.Position.Y + <span class="number">1</span>) / <span class="number">2</span> * Screen.height, <span class="number">0</span>);</span><br><span class="line">                                <span class="comment">//print(_hand.transform.position);</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">switch</span> (body.HandRightState)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">case</span> HandState.Unknown:</span><br><span class="line">                                    _hand.color = Color.blue;</span><br><span class="line">                                    _hand.sprite = _handUnkown;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> HandState.NotTracked:</span><br><span class="line">                                    _hand.color = Color.red;</span><br><span class="line">                                    _hand.sprite = _handUnkown;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> HandState.Open:</span><br><span class="line">                                    _hand.color = Color.green;</span><br><span class="line">                                    _hand.sprite = _handOpen;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> HandState.Closed:</span><br><span class="line">                                    _hand.color = Color.green;</span><br><span class="line">                                    _hand.sprite = _handClosed;</span><br><span class="line">                                    <span class="comment">//握拳的时候，就截取一张图片</span></span><br><span class="line">                                    Application.CaptureScreenshot(Application.dataPath + <span class="string">&quot;/../ScreenCapture.png&quot;</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="keyword">case</span> HandState.Lasso:</span><br><span class="line">                                    _hand.color = Color.yellow;</span><br><span class="line">                                    _hand.sprite = _handUnkown;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                <span class="literal">default</span>:</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector2 _slider;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        GUIStyle style = <span class="keyword">new</span> GUIStyle();</span><br><span class="line">        style.fontSize = <span class="number">50</span>;</span><br><span class="line">        style.normal.textColor = Color.red;</span><br><span class="line">        GUILayout.Label(_hand.transform.position + <span class="string">&quot;    &quot;</span> + _pos, style);</span><br><span class="line"></span><br><span class="line">        _slider = GUILayout.BeginScrollView(_slider);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> body <span class="keyword">in</span> _bodySet)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//if (!body.IsTracked) return;</span></span><br><span class="line"></span><br><span class="line">            GUILayout.BeginVertical(GUI.skin.box);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;对象：&quot;</span> + body.TrackingId);</span><br><span class="line">            <span class="keyword">var</span> activities = body.Activities;</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; Activities: &quot;</span> + body.ClippedEdges);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> act <span class="keyword">in</span> activities)</span><br><span class="line">            &#123;</span><br><span class="line">                GUILayout.Label(act.Key + <span class="string">&quot;:  &quot;</span> + act.Value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; Appearance: &quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> app <span class="keyword">in</span> body.Appearance)</span><br><span class="line">            &#123;</span><br><span class="line">                GUILayout.Label(app.Key + <span class="string">&quot;  &quot;</span> + app.Value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; ClippedEdges: &quot;</span> + body.ClippedEdges);</span><br><span class="line"></span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; Expressions: &quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> body.Expressions)</span><br><span class="line">            &#123;</span><br><span class="line">                GUILayout.Label(item.Key + <span class="string">&quot;  &quot;</span> + item.Value);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; HandLeftConfidence: &quot;</span> + body.HandLeftConfidence);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; HandLeftState: &quot;</span> + body.HandLeftState);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; HandRightConfidence: &quot;</span> + body.HandRightConfidence);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; HandRightState: &quot;</span> + body.HandRightState);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; IsRestricted: &quot;</span> + body.IsRestricted);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; IsTracked: &quot;</span> + body.IsTracked);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; Lean: &quot;</span> + body.Lean);</span><br><span class="line">            GUILayout.Label(<span class="string">&quot;-------&gt; LeanTrackingState: &quot;</span> + body.LeanTrackingState);</span><br><span class="line"></span><br><span class="line">            GUILayout.EndVertical();</span><br><span class="line">        &#125;</span><br><span class="line">        GUILayout.EndScrollView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnApplicationQuit</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        _sensor.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下边就是我截取得一张图片：</p><p><img src="/blogimages/oldpictures/2017.5.10-5.png"></p><p>右边很诡异的图像就是之前提到的根据深度图采样的Mesh了，越靠近相机，就越近，反之越远。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这就是最简单的一个测试了，各种信息皆有，那么根据API提供的信息，便可衍生出更多的功能。</p><p>另外，Kinect似乎也不受支持了，比如若是有心，便可注意到Kinect的SDK甚至都是两、三年前的东西了，亦即是说：微软已经两三年没为其提供支持….了么？</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;据说，前几天据说公司接到一个委托，可能要做Kinect相关的一些东西：比如小游戏或者其他一些功能之类的。&lt;br&gt;所以，就要用到Kinect了</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/categories/Unity3D/"/>
    
    
    <category term="Kinect" scheme="https://cwhisme.ml/tags/Kinect/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D以正交相机截取作大地图</title>
    <link href="https://cwhisme.ml/2017/05/07/2017-5-7-Unity-use-othographic-camera-map/"/>
    <id>https://cwhisme.ml/2017/05/07/2017-5-7-Unity-use-othographic-camera-map/</id>
    <published>2017-05-07T07:23:23.000Z</published>
    <updated>2021-06-10T06:43:19.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些天做大地图用到过一次，要求点大地图哪儿，就把玩家传送至点击的相应世界位置。而且这张大地图是事先截取好的图片。<br>要说来的话，这功能也还是“前任”留下来的，新公司之前的程序走掉之后，项目就留在那儿了，我来之后，才又开工的样子。<br>本来以为这地图应该稍稍改改就好了，结果鼠标点上去图标乱飞，人也不见了踪影….<br>定睛一看，不但地图用的是UE4项目中截取的（这项目之前公司还用UE4做了一版，不过说是因为有些功能实现不了，才又换到Unity的），其中代码注意了下，也是UE4中类似的算法提过来的样子。</p><p>本以为应该很简单，很快就改好了….不过之后大概地点没问题，但是无论怎么改，地图上都有些许误差，看起来就是点了地图上某个位置，但是实际上却偏移了一段。</p><p>然后新公司也就我一个程序，只好自个儿琢磨了。<br>后来折腾了些时候，考虑着：先不说UE4中截取的地图跟Unity中单位兼不兼容，单单是之前截取地图的比例我也不知道。<br>便思虑着是否确实是地图比例(长宽，是否对得上本身的分辨率？)不对？<br>于是就想到还是用Unity本身来截取大地图试试。</p><p>把之前代码里边定义了许多固定坐标、世界长度(貌似其实不对)之类的都删了，自个儿重新来，我采用了最简单的一种按比例计算的方式实现，这儿就稍作记录吧。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>我所做的大地图，是事先使用一个orthographic相机对场景进行截图，然后保存为一张PNG格式的图片作为大地图。</p><p>所以在此之前，我们必须要明白一点：orthographicSize。<br>在Unity正交相机模式下，orthographicSize一个单位等于Unity世界2个单位，不过仅限于纵向——也就是说纵向的可以显示的范围=orthographicSize*2。<br>比如说orthographicSize=360，那么相机实际可以显示的场景中720米的范围(纵向)。<br>而横向显示长度，则是据此并与屏幕长宽比例相关。</p><p>知道了这一点的话，那么就可以根据这个比例关系，对使用orthographic相机截取的地图进行定位了（稍微说一下：因此，若想保持比例正确，且少费功夫，其纵向长度必须保持上述比例，而宽度，则可根据比例(地图分辨率、屏幕分辨率)自行换算）。<br>之前就说了，我是用的最简单的方式——所以不考虑更多的比例关系，主要就是将鼠标点击的位置转换至UI中，因为图片、UI比例一致，所以鼠标在UI中的坐标，就可以直接被当做大地图中的实际坐标了。<br>不大清楚的话，可以这样考虑：UI的纵向长度为720，同时代表了720米的距离，UI横向长度为1024，代表了1024米的距离。</p><p>地图如下：</p><p><img src="/blogimages/oldpictures/2017.5.7-1.png" alt="地图"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在我做的项目中，UI显示的大小为1024x720，所以截图也要根据这个比例来，为了增加清晰度，截图放大了一倍，即2048x1440。<br>orthographicSize则以实际UI的比例为主，所以orthographicSize=720/2=360.</p><p>照上述所言，之前就说了是很简单的方法了，所以定位就很简单了。<br>主要就是将鼠标点击的位置转至以屏幕中心为准，这样子的话，那么地图比例依照上述，点击位置距离中心点有多远，便可依样转换至世界坐标距离原点Vector3(0,0,0)的坐标。</p><p>代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将点击位置映射至中点</span></span><br><span class="line">_clickTargetPosition = <span class="keyword">new</span> Vector2(Screen.width / <span class="number">2.0f</span>, Screen.height / <span class="number">2.0f</span>) - _clickMousePos;</span><br><span class="line"><span class="comment">//三维转二维</span></span><br><span class="line">_clickTargetPosition.z = _clickTargetPosition.y;</span><br><span class="line"><span class="comment">//UI比例缩放</span></span><br><span class="line">_clickTargetPosition /= _canvas.scaleFactor;</span><br><span class="line">_clickTargetPosition = <span class="keyword">new</span> Vector3(_clickTargetPosition.x, <span class="number">70</span>, _clickTargetPosition.z);</span><br></pre></td></tr></table></figure><p>接下来是截图。<br>截图代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MenuItem(<span class="meta-string">&quot;Tools/Capture BigMap&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CaptureBigMap</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Camera ca = <span class="keyword">new</span> GameObject(<span class="string">&quot;[Camera]&quot;</span>).AddComponent&lt;Camera&gt;();</span><br><span class="line">    ca.orthographic = <span class="literal">true</span>;</span><br><span class="line">    ca.orthographicSize = <span class="number">360</span>;</span><br><span class="line">    ca.cullingMask &amp;= ~(<span class="number">1</span> &lt;&lt; LayerMask.NameToLayer(<span class="string">&quot;Pipe&quot;</span>));</span><br><span class="line">    ca.backgroundColor = Color.black;</span><br><span class="line">    ca.clearFlags = CameraClearFlags.SolidColor;</span><br><span class="line">    ca.transform.position = <span class="keyword">new</span> Vector3(<span class="number">0</span>, <span class="number">500</span>, <span class="number">0</span>);</span><br><span class="line">    ca.transform.eulerAngles = <span class="keyword">new</span> Vector3(<span class="number">90</span>, <span class="number">180</span>, <span class="number">0</span>);</span><br><span class="line">    CaptureCamera(ca, <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2048</span>, <span class="number">1440</span>), Application.dataPath + <span class="string">&quot;/../BigMap.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DestroyImmediate(ca.gameObject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CaptureCamera</span>(<span class="params">Camera camera, Rect rect, <span class="built_in">string</span> fileName</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RenderTexture rt = <span class="keyword">new</span> RenderTexture((<span class="built_in">int</span>)rect.width, (<span class="built_in">int</span>)rect.height, <span class="number">-1</span>);</span><br><span class="line">    RenderTexture.active = rt;</span><br><span class="line">    camera.targetTexture = rt;</span><br><span class="line">    camera.Render();</span><br><span class="line">    Texture2D screenShot = <span class="keyword">new</span> Texture2D((<span class="built_in">int</span>)rect.width, (<span class="built_in">int</span>)rect.height, TextureFormat.RGB24, <span class="literal">false</span>);</span><br><span class="line">    screenShot.ReadPixels(rect, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    screenShot.Apply();</span><br><span class="line">    RenderTexture.active = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">byte</span>[] bytes = screenShot.EncodeToPNG();</span><br><span class="line">    System.IO.File.WriteAllBytes(fileName, bytes);</span><br><span class="line">    Debug.Log(<span class="string">&quot;截图完成:&quot;</span> + fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，截图大小是多少，同时也必须把屏幕的比例设置相同，当然最好、或者说最简单的方法就是直接将屏幕的分辨率设置为截图大小。<br>如图：</p><p><img src="/blogimages/oldpictures/2017.5.7-2.png"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这样，按照比例做的图片地图就好了。<br>因为地图与世界坐标比例基本一致，点哪儿传送至哪儿完全没问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;前些天做大地图用到过一次，要求点大地图哪儿，就把玩家传送至点击的相应世界位置。而且这张大地图是事先截取好的图片。&lt;br&gt;要说来的话，这功能也</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/categories/Unity3D/"/>
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>C++对UMG的控件实例化操作</title>
    <link href="https://cwhisme.ml/2017/04/26/2017-4-26-UMG-Runtime-Instantiate/"/>
    <id>https://cwhisme.ml/2017/04/26/2017-4-26-UMG-Runtime-Instantiate/</id>
    <published>2017-04-26T11:47:09.000Z</published>
    <updated>2021-05-10T02:57:25.972Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>嗯，前几天开始用UE4座第一个VR项目了，HTC Vive平台的。主要功能就是些互动：比如用控制器开开水龙头、开开关关电视、捡捡小东西、换换模型材质什么的…..功能很简单，所以想到目前处于学习阶段，就决定全用C++来实现。其它就不多赘述了，这篇Blog主要来说说UE4中使用C++操作UMG吧。</p><p>儿主要用到UI的地方，就是替换材质的功能了。<br>首先，对于替换材质这个功能来说，模型上可替换的材质数量是不定的；<br>其次，在VR中，UI必须制作成3D UI才能进行具体交互的，相较2D UI来说，要麻烦了一些—特别是交互这块儿，所以当时花了大半天才琢磨好如何制作UE4中3D UI的交互（比如正确获取3D UI中按钮点击事件等）</p><p>然后，先说说“材质不定”这个问题吧。<br>在Unity中，一般直接可以把显示每个材质的UI做个Prefab，然后根据传入数量直接进行实例化，更改其中的显示图片啊、点击事件调用的方法就可以了。<br>所以，在此我第一个想到的，也是这个方法。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>第一步一般是制作UI吧。<br>不过因为我打算将实际的代码放在UI自身上，所以在此之前，最好先建立一个UUserWidget的子类，方便管理UI操作的代码（其实代码写在UI之外也可以，不过据说那样不大推荐）</p><p>所以，首先打开项目的“项目名.Build.cs”文件，加入对UI的依赖：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FJ_Project_CPP</span><span class="params">(TargetInfo Target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PublicDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; <span class="string">&quot;Core&quot;</span>, <span class="string">&quot;CoreUObject&quot;</span>, <span class="string">&quot;Engine&quot;</span>, <span class="string">&quot;InputCore&quot;</span>, <span class="string">&quot;UMG&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    PrivateDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment if you are using Slate UI</span></span><br><span class="line">    PrivateDependencyModuleNames.<span class="built_in">AddRange</span>(<span class="keyword">new</span> string[] &#123; <span class="string">&quot;Slate&quot;</span>, <span class="string">&quot;SlateCore&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment if you are using online features</span></span><br><span class="line">    <span class="comment">// PrivateDependencyModuleNames.Add(&quot;OnlineSubsystem&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// To include OnlineSubsystemSteam, add it to the plugins section in your uproject file with the Enabled attribute set to true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以放心大胆地创建一个基于UUserWidget的子类，这儿我命名为“UMyUserWidget”。<br>接着创建一个WidgetBlueprint，并在菜单进行Reparent,选择刚才创建的UMyUserWidget。</p><p>在UI设计器中，布局如下：</p><p><img src="/blogimages/oldpictures/2017.4.26-1.png"></p><p>主要就两个组件：一个Button，一个ScrollBox。<br>Button就是用于显示“每个”材质的容器，ScrollBox则用于显示所有UI的容器，后面在代码中，会根据材质实时Copy Button，设置信息，然后添加入ScrollBox中。</p><p>注意ScrollBox重命名为“MatScrollBox”，Button命名为“ButtonPrototype”，这个名字可以用于代码中寻找这两个UI的引用，所以很重要。</p><p>接着打开“UMyUserWidget.h”，在这个类中，主要有两个自定义的方法，因为UserWidget不带“BeginPlay”子类的自动初始化的重载方法，所以我定义了一个Init()方法用来初始化<br>，做一些诸如获取相关UI(ButtonPrototype、ScrollBox)引用的事儿。<br>其次是ShowModifyMaterialUI方法，接受两个参数，用于具体处理根据材质数量、信息实例化相应UI的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowModifyMaterialUI</span><span class="params">(UStaticMeshComponent* mesh, TArray&lt;FMaterialPair&gt; materialDataList)</span></span>;</span><br></pre></td></tr></table></figure><p>然后是一些私有变量或者函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">UScrollBox* _scrollBox;</span><br><span class="line">UButton* _buttonPrototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击的Button</span></span><br><span class="line">UButton* _clickTempButton;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更换材质的模型引用</span></span><br><span class="line">UStaticMeshComponent* _mesh;</span><br><span class="line">TArray&lt;FMaterialPair&gt; _materialDataList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储点击按钮的回调</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnClick</span><span class="params">()</span></span>;<span class="comment">//具体执行点击按钮方法</span></span><br><span class="line"><span class="built_in">UFUNCTION</span>()</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCheckClickButton</span><span class="params">()</span></span>;<span class="comment">//用以判断点中的按钮</span></span><br></pre></td></tr></table></figure><p>然后进入MyUserWidget.cpp，实现Init等方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyUserWidget::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过名字来获取显示材质的ScrollBox</span></span><br><span class="line">_scrollBox = Cast&lt;UScrollBox&gt;(<span class="built_in">GetWidgetFromName</span>(<span class="built_in">FName</span>(<span class="string">&quot;MatScrollBox&quot;</span>)));</span><br><span class="line"></span><br><span class="line">_buttonPrototype = Cast&lt;UButton&gt;(<span class="built_in">GetWidgetFromName</span>(<span class="built_in">FName</span>(<span class="string">&quot;ButtonPrototype&quot;</span>)));</span><br><span class="line"><span class="keyword">if</span> (_buttonPrototype)</span><br><span class="line">_buttonPrototype-&gt;<span class="built_in">SetVisibility</span>(ESlateVisibility::Hidden);</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetVisibility</span>(ESlateVisibility::Hidden);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，获取了Button和ScrollBox的引用，并且隐藏了用于实例化的Button原型。</p><p>接着，就是重点的ShowModifyMaterialUI方法了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyUserWidget::ShowModifyMaterialUI</span><span class="params">(UStaticMeshComponent* mesh, TArray&lt;FMaterialPair&gt; materialDataList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//缓存材质、Mesh</span></span><br><span class="line">_mesh = mesh;</span><br><span class="line">_materialDataList = materialDataList;</span><br><span class="line"></span><br><span class="line">_scrollBox-&gt;<span class="built_in">ClearChildren</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> mat = materialDataList.<span class="built_in">CreateIterator</span>(); mat; ++mat)</span><br><span class="line">&#123;</span><br><span class="line">FMaterialPair data = (*mat);</span><br><span class="line">UTexture* tex = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取显示的图片</span></span><br><span class="line"><span class="comment">//若指定了相应的图片，则直接显示相应图片</span></span><br><span class="line"><span class="comment">//否则，抓取材质中的图片进行显示</span></span><br><span class="line"><span class="keyword">if</span> (data.Icon == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">TArray&lt;UTexture*&gt; texs;</span><br><span class="line">data.Material-&gt;<span class="built_in">GetUsedTextures</span>(texs, EMaterialQualityLevel::Medium, <span class="literal">true</span>, ERHIFeatureLevel::SM5, <span class="literal">true</span>);<span class="comment">// GetTextureStreamingData();</span></span><br><span class="line"><span class="keyword">if</span> (texs.<span class="built_in">Num</span>() &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tex = texs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tex = data.Icon;</span><br><span class="line"></span><br><span class="line">UButton* button = DuplicateObject&lt;UButton&gt;(_buttonPrototype, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置按钮的显示</span></span><br><span class="line">button-&gt;WidgetStyle.Normal.<span class="built_in">SetResourceObject</span>(tex);</span><br><span class="line">button-&gt;WidgetStyle.Hovered.<span class="built_in">SetResourceObject</span>(tex);</span><br><span class="line">button-&gt;WidgetStyle.Pressed.<span class="built_in">SetResourceObject</span>(tex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//绑定按钮的方法</span></span><br><span class="line">button-&gt;OnPressed.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UMyUserWidget::OnCheckClickButton);</span><br><span class="line">button-&gt;OnClicked.<span class="built_in">AddDynamic</span>(<span class="keyword">this</span>, &amp;UMyUserWidget::OnClick);</span><br><span class="line">button-&gt;<span class="built_in">SetVisibility</span>(ESlateVisibility::Visible);</span><br><span class="line">_scrollBox-&gt;<span class="built_in">AddChild</span>(button);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetVisibility</span>(ESlateVisibility::Visible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，最主要就是通过复制开始的原型按钮实现功能。<br>另外因为按钮点击一类的回调使用了动态多播委托，在UE4中是这种的委托是不允许Lambda表达式的，所以必须定义两个方法：一个用来判断选择的按钮，一个用于当实际点击触发的时候执行。<br>其中判断选中哪个按钮用的是“按下”事件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyUserWidget::OnCheckClickButton</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">3</span>, FColor::Orange, <span class="built_in">TEXT</span>(<span class="string">&quot;Check Click&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buttonCount = _scrollBox-&gt;<span class="built_in">GetChildrenCount</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; buttonCount; i++)</span><br><span class="line">&#123;</span><br><span class="line">UButton* button = Cast&lt;UButton&gt;(_scrollBox-&gt;<span class="built_in">GetChildAt</span>(i));</span><br><span class="line"><span class="keyword">if</span> (button-&gt;<span class="built_in">IsPressed</span>())</span><br><span class="line">&#123;</span><br><span class="line">_clickTempButton = button;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，当实际点击事件触发时，就可以根据按下按钮确定被点击按钮是谁？因为材质数量与按钮一一对应，所以就根据这个按钮的索引进行材质的替换了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UMyUserWidget::OnClick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_clickTempButton != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> index = _scrollBox-&gt;<span class="built_in">GetChildIndex</span>(_clickTempButton);</span><br><span class="line">GEngine-&gt;<span class="built_in">AddOnScreenDebugMessage</span>(<span class="number">-1</span>, <span class="number">3</span>, FColor::Orange, <span class="built_in">TEXT</span>(<span class="string">&quot;Click &quot;</span> + _clickTempButton-&gt;<span class="built_in">GetName</span>() + <span class="string">&quot;  Index: &quot;</span> + FString::<span class="built_in">FromInt</span>(index)));</span><br><span class="line">_mesh-&gt;<span class="built_in">SetMaterial</span>(<span class="number">0</span>, _materialDataList[index].Material);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">SetVisibility</span>(ESlateVisibility::Hidden);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，FMaterialPair是一个自定义的结构体，存储了材质以及一个用于显示的ICON：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">USTRUCT</span>(BlueprintType)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FMaterialPair</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="built_in">GENERATED_USTRUCT_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = Materials)</span><br><span class="line">UTexture* Icon;</span><br><span class="line"><span class="built_in">UPROPERTY</span>(EditAnywhere, Category = Materials)</span><br><span class="line">UMaterialInstance* Material;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其规则是：若指定了材质的显示图片，那么UI上就直接显示这个图片，否则则抓取材质中的贴图进行显示。</p><p>编辑界面如下：</p><p><img src="/blogimages/oldpictures/2017.4.26-2.png"></p><p>效果：</p><p><img src="/blogimages/oldpictures/2017.4.26-3.png"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>恩，功能上是没问题的。<br>因为主要是介绍UI的，所以其它交互实现就不多提了，换材质的交互为了设置的方便，我是用组件方法实现的：差不多就是在一个Mesh上挂一个组件，然后就像上图那样设置下可替换材质就可以了。<br>另外有点不和谐就是：大概因为材质问题，3D UI在世界空间中直接显示的时候，明显“发白”了（估计是受到了UE4各种附加特效的伤害~）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;嗯，前几天开始用UE4座第一个VR项目了，HTC Vive平台的。主要功能就是些互动：比如用控制器开开水龙头、开开关关电视、捡捡小东西、换换</summary>
      
    
    
    
    <category term="UE4" scheme="https://cwhisme.ml/categories/UE4/"/>
    
    
    <category term="UE4" scheme="https://cwhisme.ml/tags/UE4/"/>
    
    <category term="C++" scheme="https://cwhisme.ml/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>UE4中的委托与事件</title>
    <link href="https://cwhisme.ml/2017/04/07/2017-4-7-UE4-Delegate-and-Event/"/>
    <id>https://cwhisme.ml/2017/04/07/2017-4-7-UE4-Delegate-and-Event/</id>
    <published>2017-04-07T11:54:03.000Z</published>
    <updated>2021-05-10T02:57:25.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在U3D中，因为主要是以C#为主，C#原生支持事件、委托。用起来很方便，不但可以降低模块之前的耦合，而且它还可以提供一种优秀的性能提升方式：只有当值真的改变，并且必要的时候，对需要的对象进行通知，避免外部不断地对变量进行读取判断。所以也经常用到。</p><p>虽然委托是C#中的语法，C++标准语法里边虽然没这东西，不过在UE4中，被改造后的语法同样提供了相应的实现方法。</p><p>那么，接下来就来看看吧。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><h3 id="无参委托"><a href="#无参委托" class="headerlink" title="无参委托"></a>无参委托</h3><p>对于声明非常简单，在类的声明之前，使用DECLARE_DELEGATE进行定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_DELEGATE(FAction)</span><br></pre></td></tr></table></figure><p>为了方便测试，我建立了一个“ADelegateTestActor”的Actor以及一个“UDelegateTestActorComponent”的组件,并在该组件开始游戏中，向委托进行注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AActor* actor = GetOwner();</span><br><span class="line">if (actor != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">ADelegateTestActor* del = Cast&lt;ADelegateTestActor&gt;(actor);</span><br><span class="line">if (del != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">del-&gt;OnTestInvoke.BindLambda([]() &#123;GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot;委托测试！&quot;)); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Actor的构造函数中，则直接为自己添加一个“UDelegateTestActorComponent”，这样，将Actor放入场景之后，自动就具有了测试组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADelegateTestActor::ADelegateTestActor()</span><br><span class="line">&#123;</span><br><span class="line">// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don&#x27;t need it.</span><br><span class="line">PrimaryActorTick.bCanEverTick = true;</span><br><span class="line"></span><br><span class="line">UDelegateTestActorComponent* o = CreateDefaultSubobject&lt;UDelegateTestActorComponent&gt;(&quot;DelCmp&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是委托的调用了，简单地使用了一个延时调用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetWorldTimerManager().SetTimer(_timeHandle, [this]() &#123;OnTestInvoke.ExecuteIfBound(); GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot;调用&gt;&gt;&gt;&quot;)); &#125;, 1, false, 3);</span><br></pre></td></tr></table></figure><p>OK，第一个委托及其测试都搞定了。<br>返回UE4，编译一下，然后将“ADelegateTestActor”放入场景，运行：</p><p><img src="/blogimages/oldpictures/2017.4.7-1.png"></p><p>见到上述打印，就说明成功执行了。<br>看起来是很简单吧？其实也跟C#的实现差不多。</p><h3 id="有参委托"><a href="#有参委托" class="headerlink" title="有参委托"></a>有参委托</h3><p>有参委托与无参数委托用法差不多，只是定义改了一下，这儿就来简单看看一个参数的委托吧.<br>首先是定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_DELEGATE_OneParam(FAction_One, FString)</span><br></pre></td></tr></table></figure><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FAction_One OnOneParamInvoke;</span><br></pre></td></tr></table></figure><p>注册，依然是在“UDelegateTestActorComponent”开始时进行，这次除了打印一个固定的语句，同时加上了委托传过来的参数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AActor* actor = GetOwner();</span><br><span class="line">if (actor != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">ADelegateTestActor* del = Cast&lt;ADelegateTestActor&gt;(actor);</span><br><span class="line">if (del != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">del-&gt;OnOneParamInvoke.BindLambda([](FString param) &#123;GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot;委托测试！  &quot;+ param)); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetWorldTimerManager().SetTimer(_timeHandle, [this]() &#123;OnOneParamInvoke.ExecuteIfBound(&quot;&gt;Hello World!&lt;&quot;); GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot;调用&gt;&gt;&gt;&quot;)); &#125;, 1, false, 3);</span><br></pre></td></tr></table></figure><p>在调用时，同时传入了一个字符串参数，我这儿还是以“Hello World”为例吧。</p><p>最后运行效果：</p><p><img src="/blogimages/oldpictures/2017.4.7-2.png"></p><p>其他与委托相关，多个参数均需要使用相应的宏定义进行声明，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_DELEGATE_OneParam</span><br><span class="line">DECLARE_DELEGATE_TwoParams</span><br><span class="line">DECLARE_DELEGATE_ThreeParams</span><br><span class="line">DECLARE_DELEGATE_FourParams</span><br><span class="line">DECLARE_DELEGATE_FiveParams</span><br><span class="line">DECLARE_DELEGATE_SixParams</span><br><span class="line">DECLARE_DELEGATE_SevenParams</span><br><span class="line">DECLARE_EVENT_EightParams</span><br><span class="line">DECLARE_DELEGATE_NineParams</span><br></pre></td></tr></table></figure><h3 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h3><p>上述委托用起来没问题。<br>但是，会有一个限制：只能绑定一个方法。</p><p>如果有新的方法绑上去，就会变成新的方法，旧有的就会被丢掉，不相信的话，可以创建两个“”组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CreateDefaultSubobject&lt;UDelegateTestActorComponent&gt;(&quot;DelCmp&quot;);</span><br><span class="line">CreateDefaultSubobject&lt;UDelegateTestActorComponent&gt;(&quot;DelCmp2&quot;);</span><br></pre></td></tr></table></figure><p>然后在绑定委托方法中加一句，顺便打印一下组件的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del-&gt;OnOneParamInvoke.BindLambda([this](FString param) &#123;GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(  &quot; 委托测试！  &quot; + GetName() +&quot;  &quot;+ param)); &#125;);</span><br></pre></td></tr></table></figure><p><img src="/blogimages/oldpictures/2017.4.7-3.png"></p><p>就是这样。</p><p>所以就有了多播委托，多播委托运行绑定多个方法，并在绑定方法时，返回一个唯一的指针，以便后续对指定单个方法进行解绑。</p><p>声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_MULTICAST_DELEGATE_OneParam(FMultiAction, FString);</span><br></pre></td></tr></table></figure><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FMultiAction OnMultiOneParamInvoke;</span><br></pre></td></tr></table></figure><p>绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AActor* actor = GetOwner();</span><br><span class="line">if (actor != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">ADelegateTestActor* del = Cast&lt;ADelegateTestActor&gt;(actor);</span><br><span class="line">if (del != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">del-&gt;OnMultiOneParamInvoke.AddLambda([this](FString param) &#123;GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot; 委托测试！  &quot; + GetName() + &quot;  &quot; + param)); &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetWorldTimerManager().SetTimer(_timeHandle, [this]() &#123;OnMultiOneParamInvoke.Broadcast(&quot;&gt;Hello World!&lt;&quot;); GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot;调用&gt;&gt;&gt;&quot;)); &#125;, 1, false, 3);</span><br></pre></td></tr></table></figure><p>这儿我只是简单地测试，就没有缓存其返回值，如果有需要的话，是可以使用其进行方法解绑的。</p><p>效果:</p><p><img src="/blogimages/oldpictures/2017.4.7-4.png"></p><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件跟委托差不多，与C#中的概念也没差多少，它只是相当于“受限的委托“。限制其调用只能由指定的类进行。</p><p>并且，事件默认就是“多播”，不存在像默认委托一样，一个事件只能绑一个方法的说法。</p><p>声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_EVENT_OneParam(ADelegateTestActor, FEvent_One, FString)</span><br></pre></td></tr></table></figure><p>在声明中与委托唯一的不同就是，需要多传入一个参数：限制只能调用的类的类型。<br>比如在此定义之后，就只能允许“ADelegateTestActor”这个类进行委托的调用——本来我是很想这样写的，但是…实际用的时候，还是发现跟多播委托差不多，外部都可以调用。<br>例如，在“”组件中，绑定事件后。立刻调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AActor* actor = GetOwner();</span><br><span class="line">if (actor != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">ADelegateTestActor* del = Cast&lt;ADelegateTestActor&gt;(actor);</span><br><span class="line">if (del != nullptr)</span><br><span class="line">&#123;</span><br><span class="line">del-&gt;OnEventInvoke.AddLambda([this](FString param) &#123;GEngine-&gt;AddOnScreenDebugMessage(-1, 5, FColor::Magenta, TEXT(&quot; 事件测试：  &quot; + GetName() + &quot;  &quot; + param)); &#125;);</span><br><span class="line"></span><br><span class="line">del-&gt;OnEventInvoke.Broadcast(FString(&quot;Hello Event&quot;));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不报错，编译也能通过…..</p><p>运行：<img src="/blogimages/oldpictures/2017.4.7-5.png"></p><p>So…容我再研究下，这篇Blog就先到这儿了吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在U3D中，因为主要是以C#为主，C#原生支持事件、委托。用起来很方便，不但可以降低模块之前的耦合，而且它还可以提供一种优秀的性能提升方式：</summary>
      
    
    
    
    <category term="UE4" scheme="https://cwhisme.ml/categories/UE4/"/>
    
    
    <category term="UE4" scheme="https://cwhisme.ml/tags/UE4/"/>
    
    <category term="C++" scheme="https://cwhisme.ml/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>UE4.15 不允许使用不完整的类型错误</title>
    <link href="https://cwhisme.ml/2017/03/20/2017-3-20-UE4-Incomplete-types-are-not-allowed/"/>
    <id>https://cwhisme.ml/2017/03/20/2017-3-20-UE4-Incomplete-types-are-not-allowed/</id>
    <published>2017-03-20T12:59:41.000Z</published>
    <updated>2021-05-10T02:57:25.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上周最终还是找了份工作——不过已经不是做游戏什么的了——而是VR、AR…据说后面还有MR之类的。<br>虽然换了一份工作，待遇毫无长进——毕竟现在行情似乎不大好，也没办法了。毕竟，稳定和可持续发展才是王道吧。<br>(好吧，我承认是为了继续待在重庆，然后重庆找不着合适的游戏公司了，加上考虑自己对UE4感兴趣，然后大家都在说VR后面或许发展比手游更好之类的，所以就毅然转行了)</p><p>上周入职之后，算是把Oculus DK2、HTC Vive、Gear VR摸了个遍——当然是用Unity，基本上接口不难，大半天就熟悉了。<br>而据说新公司主要是使用UE4，所以，最主要的还是：学习UE4。</p><p>作为一个程序，我其实是不是很喜欢蓝图，因此主要还是研究C++的实现。<br>但是作为Unity转过来的程序，编程语言突然被从C#变成了C++——用起来感觉处处都透着一股奇怪。加上UE4对于C++相关接口每次发版本都要变，碰上问题都很可能就是“最新”的了。</p><p>比如这次。</p><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>这次其实也是一个简单的问题，但着实花了些时间来琢磨。其原因大概是官方的4.15的解释：“更快的C++编译时间：‘虚幻引擎 4 代码库现在的编译速度提升了 50%！头文件只包含其所需的其他标头，而不是每个包含大型单体标头（例如 Engine.h 和 UnrealEd.h）的源文件 - 我们将这一做法称为含您所用（IWYU）。’”<br>然后直接结果就是，本来在早一点版本的UE4写的好好代码，升级到最新UE4.15之后，当我们在使用某些接口的时候，直接被编译器提示：“不允许使用不完整的类型”(当然也有其它类型的文字提示，但意思应该差不多)</p><p>最普遍的，比如说我想要画一条线:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ULineBatchComponent*  lineBatch = <span class="built_in">GetWorld</span>()-&gt;PersistentLineBatcher;</span><br><span class="line"><span class="keyword">if</span> (lineBatch != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">lineBatch-&gt;<span class="built_in">DrawLine</span>(<span class="built_in">GetActorLocation</span>(), <span class="built_in">GetActorForwardVector</span>() * <span class="number">10</span>, FLinearColor::Red, <span class="number">-1</span>, LineSize, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会得到这样的提示，并且编译无法通过：</p><p><img src="/blogimages/oldpictures/2017.3.20-1.png" alt="错误"></p><p>而在UE4.15版本中，要解决这个错误，就必须手动添加头文件的引用了。<br>比如画线这个组件的头文件是LineBatchComponent.h，我们就必须在代码前边手动包含它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Components/LineBatchComponent.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不然就是报错“不允许指针指向不完整的类型”。<br>最蛋痛的是，C++包含的时候必须有这个头文件的路径。也就是说，你得找到他的路径，或者见着某个代码是如何包含的才行…虽然可以按下F12可以定位，但是好慢啊…</p><p>再来举个栗子：添加输入按键映射。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPlayerInput::<span class="built_in">AddEngineDefinedActionMapping</span>(<span class="built_in">FInputActionKeyMapping</span>(<span class="string">&quot;Jump&quot;</span>, EKeys::SpaceBar));</span><br></pre></td></tr></table></figure><p>直接这样子写也是不行的，错误是“不允许使用不完整的类型”，所以必须包含完整路径的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;GameFramework/PlayerInput.h&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>所以，使用UE4.15或者更新版本的话，大概都会有这问题(如果官方本来就是这样打算的话，自己想要什么就必须自己添加头文件…),就要稍微多动动手了，明白问题所在，当然解决也快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上周最终还是找了份工作——不过已经不是做游戏什么的了——而是VR、AR…据说后面还有MR之类的。&lt;br&gt;虽然换了一份工作，待遇毫无长进——毕</summary>
      
    
    
    
    <category term="UE4" scheme="https://cwhisme.ml/categories/UE4/"/>
    
    
    <category term="UE4" scheme="https://cwhisme.ml/tags/UE4/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D性能优化总结</title>
    <link href="https://cwhisme.ml/2017/03/09/2017-3-9-Unity-Optimization-Summary/"/>
    <id>https://cwhisme.ml/2017/03/09/2017-3-9-Unity-Optimization-Summary/</id>
    <published>2017-03-09T03:36:48.000Z</published>
    <updated>2021-05-10T02:57:25.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>关于Unity3D中的各种优化方式，相信早已是个老生常谈的问题了，不少人都开过坑。<br>为了避免让人觉得不开坑的话，就好像不知道这些优化措施一样，索性我也来这么一次。</p><p>说到对游戏的优化，有过相关了解的人，首先应该知道公认的主要有三个方面：CPU、GPU、内存相关优化。<br>这三个方面，也即是关乎整个游戏运行效率的三个“根”节点。</p><p>好了，那么下面有请在无数示例中都有所贡献的 “Window 绘图工具”——我很想这样说，不过由于最后画出来发现因为太复杂，导致很难看，所以决定直接用文字排版算了(我会注意按照相应顺序进行排版的)。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p>1.DrawCall</p><ul><li><p>Dynamic Batching<br>动态批处理，所有操作都已经由引擎自动完成了，不需要我们做任何事儿。<br>需要注意的只有“是否满足要求”：</p><ul><li>Mesh顶点小于900(若Shader使用过Normnal、UV、Position等，顶点支持小于300)</li><li>材质不同，不支持</li><li>拥有lightmap的物件不能批处理</li><li>多通道的Shader会妨碍批处理操作，接受实时阴影的物件无法批处理</li><li>满足上诉条件，但是缩放不同也不能支持<br>所以都说，动态批处理限制很多，最好用静态批处理。</li></ul></li><li><p>Static Batching<br>静态批处理，相比动态批处理来说，限制更小(缩放、顶点等没啥影响)。在不需要移动的物体上勾选Static即可。当勾选Static之后，在场景时就会将其合并至“Combined Mesh”中，相当于该GameObject已经失去了“自我”，所以也无法再行移动。<br>如图：<br><img src="/blogimages/oldpictures/2017.3.9-1.png" alt="Static Batching"><br>这种方式可以将使用了相同材质的任意大小物体进行合并，以减少Drawcall。<br>PS：材质不同DrawCall是降低不了的，这点类似动态批处理，所以不要以为勾选了Static就完事儿了！因此再分细一点的话，还需将各个GameObject使用的小的贴图合并成大的图集，并采用相同材质进行优化。<br>另外，再来一点：对于StaticBatching还可以使用代码<code>StaticBatchingUtility.Combine()</code>进行StaticBatching处理。</p></li><li><p>遮挡剔除<br>Unity自带了Occlusion Culling烘培工具，可进行遮挡剔除的烘培处理。</p></li><li><p>视椎体剔除<br>可以通过调整相机的Near、Far剪裁平面距离进行一定优化。</p></li><li><p>摄像机分层距离剔除(Per-Layer Cull Distances)<br>关于这个，可以在主相机<code>Camera.main.layerCullDistances</code>进行设置。</p></li><li><p>光照<br>实时光照+阴影会极大地增加Drawcall，因为带有光源计算的Shader因为使用额外Pass计算阴影造成Drawcall增加。 一般情况下，最好使用烘焙光照贴图+LightProp等优化。<br>(PS:实时光照阴影真的很耗，没昼夜切换的要求就算了吧，就算有，若没有实时光照改变的需求，也可以通过烘培多张LightMap来Trick。)</p></li><li><p>骨骼</p></li><li><p>没有动画的物体，在导入时务必确保删除了动画组件(有时候模型没动画也会自动被添加)</p></li></ul><p>2.物理</p><ul><li>碰撞器<br>各个碰撞器性能(由小至大)：<br>SphereCollider-&gt;CapsuleCollider-&gt;BoxCollider-&gt;MeshCollider<br>其中MeshCollider完全是“能不用就千万别用”的典范。<br>平时可以根据上面排行，进行选择吧。</li><li>物理查询<br>尽量少用，并且不要每帧查询。(比如检测地面之类的)</li></ul><p>3.GC</p><p>GC是.Net的垃圾回收机制，虽然主要是处理内存，但是在进行内存回收的时候，会极大地增加CPU的负担，所以…也是需要注意的一点，尽量少触发GC。<br>比如：</p><ul><li>链接字符串</li><li>使用For代替Foreach</li><li>减少创建新对象的频率，如使用对象池技术</li><li>能使用Struct的时候就不要用Class</li><li>等…</li></ul><p>4.代码<br>    代码优化涉及到的东西就多了，而且相信各有各的经验，就不多提了。<br>    (其中部分内容可参考下文的“代码内存”优化)</p><h3 id="GPU优化"><a href="#GPU优化" class="headerlink" title="GPU优化"></a>GPU优化</h3><p>对于GPU方面的优化，主要有下面几个：</p><ul><li><p>顶点数量</p><ul><li>让美术优化模型(比如使用法线、视差贴图代替高模渲染)</li><li>使用LOD</li><li>若模型并未使用法线贴图，可以在导入的时候关闭Normals&amp;Tangents导入。</li><li>遮挡剔除(上面CPU优化也有提到)</li><li>视椎体剔除(上面CPU优化也有提到)</li><li>摄像机分层距离剔除(Per-Layer Cull Distances)(上面CPU优化也有提到)</li></ul></li><li><p>像素填充率</p><ul><li>尽量少使用透明物体<br>为什么呢？据说是因为现代显卡大多采用了Early-Z技术，进行透明物体处理将会与其发生冲突，导致更多的像素需要被处理。</li><li>实时光与阴影</li></ul></li><li><p>显存带宽</p><ul><li>压缩纹理贴图</li><li>使用Mipmap<br>Mipmap可根据需要，向GPU发送更小细节的图片进行渲染。</li></ul></li><li><p>Shader</p><ul><li>可以的情况下，尽量使用Fixed、Half代替Float进行计算。</li><li>在Shader的Fragment中进行更少的计算，可能的话，移至Vertex程序中计算，并由GPU插值。</li><li>尽量不使用If语句</li><li>手机游戏就不要使用Standard Shader了，若有需要，可以使用Mobile Shader或者自己写个V&amp;F Shader。(Mobile Shader使用的是Surface Shader，多了很多冗余代码)</li></ul></li></ul><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><ul><li>代码内存(.Net托管内存)<ul><li>链接大量字符串使用StringBuilder</li><li>For代替Foreach</li><li>使用Struct(值类型)代替Class(引用类型)，另外，若使用Struct，一般可配合Ref关键字避免大量拷贝。</li><li>减少局部变量(或使用成员变量代替)</li><li>使用对象池技术，减少创建新对象的频率</li><li>等(待补充…)</li></ul></li><li>Unity内存<ul><li>对动态加载的资源(Resources.load或者AssetBundle)使用完毕后，使用相应接口进行释放。<br>(Resources.UnloadUnusedAssets()、assetBundle.Unload(false))</li><li>纹理压缩</li><li>图集</li><li>等(待补充…)</li></ul></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>目前总结如此，简单罗列了下自己所了解到的内容，后续会根据我自己的了解，进行对应的补充。</p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;关于Unity3D中的各种优化方式，相信早已是个老生常谈的问题了，不少人都开过坑。&lt;br&gt;为了避免让人觉得不开坑的话，就好像不知道这些优化措</summary>
      
    
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/categories/Unity3D/"/>
    
    
    <category term="优化" scheme="https://cwhisme.ml/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity3D 程序面试[2017.3.3]</title>
    <link href="https://cwhisme.ml/2017/03/05/%E9%9D%A2%E8%AF%95-2017-3-5/"/>
    <id>https://cwhisme.ml/2017/03/05/%E9%9D%A2%E8%AF%95-2017-3-5/</id>
    <published>2017-03-05T02:37:06.000Z</published>
    <updated>2021-01-02T07:14:57.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次记录的是3月3日的面试。</p><p>这是也第二次技术面试——前一次的记录也写过，就是2月14号的<a href="http://www.cwhisme.com/2017/02/14/2017-2-14-%E9%9D%A2%E8%AF%95/">那一次</a>。</p><p>那么，以下是记录。</p><h3 id="绪"><a href="#绪" class="headerlink" title="绪"></a>绪</h3><p>这次是去的成都——应该算是一个大公司吧——具体细节就不透露了，因为看见面试之前填的一个单子还是有保密保证的。</p><p>3月2日(还是1号呢？)，星期四投的简历，然后下午7点左右接到了通知，问明天(3月3日)有没有空？毕竟现在都是自由之身，所以直接就回答“应该有”了。然后收到了一条面试短信，邀请第二天2:30前往成都天府软件园去面试。<br>所以当天晚上，仔细查询了一下路线，估计了一下时间，订好了车票。</p><p>第二天一大早就起了床，出去买了早餐——因为觉得下午或者晚上大约也回不来了，所以就没有按照平时的习惯，顺便买菜。<br>吃完早餐，再呆了一会儿，10点左右出发了。<br>坐着轻轨到了重庆北站-南广场。</p><p>刚下地铁，就有一个女人问：你要到哪儿？</p><p>我想了下，如实回答道：“成都”。<br>问：“成都？买票了没？”<br>答：“买了”<br>问：“成都？是火车票还是动车票？”<br>答：“…动车吧”<br>问：“是好久的？”<br>答：“11点42的”</p><p>女人顿时很惊讶地说，你的票这边怕是来不及了，这边只有坐火车，北站那边还有好远！</p><p>我看了她下，感觉可能是在骗我。没有回话，就直接向出口那边走了。</p><p>不过眼角余光似乎看见她在向旁边，一个柱子下坐的男人招呼。<br>然后，那个男人就跟上来了。</p><p>出了地铁，我就直接向广场那边，液晶屏显示路线的告示那边走。没想到男人直接跟了上来，招呼我说，时间上来不及了，动车要去北广场坐车，那得江北机场那边了！</p><p>我说不怕，还有一个小时呢。</p><p>男人依然不死心地追着我，说我用摩托拉你过去，只要30块！你好办事儿嘛。</p><p>我摇头。</p><p>这时候差不多也走到广场告示牌前了，只看了一眼，心里“咯噔”一下，感觉坏了——因为滚动播列车信息的告示牌下，有个蓝色的牌子，写着“G、K、D…”什么的动车车次请前往北广场乘车，还标示了一个“右行100米乘坐663路公交前往北广场”——也就是说，那两人没骗我么？两年没坐过火车了，大概确实发生了些变化罢。</p><p>回头看了下，男人还在。立刻走过来说，这边去北广场好远的，少说也要四、五十分钟，你不够了，坐我的摩托吧。</p><p>我手上的百度地图一直是开着的，立即放大了地图信息，但是发现“南广场”、“北广场”明明是链接在一块区域的啊？地图上看，差不多相对而立，就是绕的路有点曲折。北广场更靠近龙头寺轻轨站。</p><p>我计算了一下路径及时间，发现差不多半个小时应该就能到(事实是当时计算路径错误，坑地图给出的是步行30分钟….)，当时差不多是10点40左右，算算时间应该足够——就算不够，延误了时机，我也不想跟着这些车站招揽的人的意思走！(毕竟曾经确实被坑过了)</p><p>然后我就一直往公交车站走，上车。</p><p>公交车运行时，我也开着地图GPS查看着，结果很快发现，不到2分钟，公交车就走了好大一段路程。</p><p>几分钟后，北广场到了。</p><p>然后才终于松了口气，同时也庆幸自己没上当。不过，当时确实动摇了——果然在紧急时候，容易被外力影响。所以车站才多骗子，多被骗。</p><p>车票是G8516 11:42 重庆北-&gt;成都东。</p><p>进了车站，在大厅坐了大概20几分钟就开始检票了。</p><p>一路无事。</p><p>到达成都东站，是在1点多，跟计划差不多，然后经过40分钟左右轻轨，应该能在2:30左右赶到公司。</p><p>不过，我似乎忽视了一个问题：1点多了，午饭怎么办？<br>在车站的便利店买了一桶方便面，一瓶矿泉水。便利店提供了热水，站在附近匆忙解决了。</p><p>不过这时候，差不多2点了。</p><p>地铁差不多还有20个站，加上中途等车之类的时间——预算堪忧啊。</p><p>后来坐到一般多路程，我还是忍不住向人事的电话发了一条短信，说明了一下迟到原因。</p><p>最后，3点过几分的时候，到达了天府五街。</p><p>下了地铁，就到公司了。</p><h3 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h3><p>出地铁，感觉不愧是软件园，一切都显得那么“高大上”，地面都是干干净净的——原谅我的词语匮乏，反正就是感觉很厉害的样子。对面我还看见“腾讯”两个大字了。</p><p>按照短信上的地址，找到了公司所在大楼，一层大厅还有一个保安，不过进去的时候并没有检查什么。</p><p>到了指定楼层，稍微收拾了一下紧张的心情。右转的玻璃门中，似乎就是前台了。对着玻璃门，我考虑了一下，“啪”地一声按下了门口右边的黑色开关————走廊的灯灭了，尴尬…赶紧再打开。</p><p>走过去稍微推了一下玻璃门，纹丝不动——证明这个门应该确实是自动的。这时里边的前台好像也注意到我了，玻璃门自动向两边分开。</p><p>正对面是许多的小圆桌子，以及看起来很奇怪的椭圆形椅子，而且高度很低。<br>左边的就是前台了。</p><p>我想了下，直接走到了前台，说：你好，我是面试的。</p><p>按照正常流程，应该会给我一张填写个人信息的纸——确实给了我一张。</p><p>刚坐下把名字写上，就看见旁边要求写前公司的薪资以及期望薪资的栏目……真的，经过上一次公司的洗礼，我都已经打算不想填这个了，但是明显的栏目，不填的话….所以还是写了，然后期望薪资，就填写的以前工资上浮30%左右的值(上一次也是这样要求的，但是结果是一分钱都没给上浮…)。</p><p>填好之后，最后还有一栏签名，不得透露面试环节中什么的，造成危害公司利益——所以，后面我就只稍微记录一下尚可。<br>全部完成，交给了前台。</p><p>前台说稍等，然后我就坐了回去。</p><p>过了一会儿，前台接了一杯水递了过来，我道了一下谢谢。</p><p>再等了一会儿，我将杯子放在桌上，四处打量了下，注意到了前台对面的墙壁——上面嵌满了透明的凸槽，里面放了很多像是奖杯、证书一类的东西。墙壁中间开了一道小门，所以将其分成了两块，不过两块都那般的装饰。</p><p>小门里面是一些座位，而且现在好像还正有些人在商量着什么。<br>略过这些，我站起来走到了右边靠大门位置的墙壁，开始观察那些证书、奖杯。</p><p>再过一会儿，听到身后有人在叫我的名字，我赶紧回到了前台，是个女生，拿着一叠像是试卷的东西。<br>看了我一下，递给我说，先做一份笔试题吧。</p><p>向前台要了一支笔，我又坐了下来。</p><p>笔试题分为了A卷 C#基础和B卷 Unity知识。分量看着还是挺足的。</p><p>在我埋头做笔试题期间，还来过一个应届毕业的女生，面试的是策划还是什么职位。后来被带到那两面“奖杯墙”里面，声音很大，不过感觉面试挺机械化的。听起来像是事先背诵的词。</p><p>然后一直做题一直做题….期间有送快递的、有请假的，也有要签字的人，虽然感觉到过了挺久，不过并不清楚时间，因为毕竟是在做笔试题，也不敢随便把手机掏出来。</p><p>后面写得桌子上沾了一大块墨水…汗…</p><h4 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h4><p>其中，令我印象最深(或者说感觉做起来有问题)的主要有三个题：</p><h5 id="1-单链表逆序；合并两个有序链表，并保持同样有序；使用递归合并链表"><a href="#1-单链表逆序；合并两个有序链表，并保持同样有序；使用递归合并链表" class="headerlink" title="(1)单链表逆序；合并两个有序链表，并保持同样有序；使用递归合并链表"></a>(1)单链表逆序；合并两个有序链表，并保持同样有序；使用递归合并链表</h5><p>这个题有三问，三问都是要手写代码实现….做到这个题的时候，我把第一问做了，留下了后面两问…没法实际测试，感觉相当烧脑。<br>第一问，我是采用递归实现的，大致代码就像这样：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">Reverse</span>(<span class="params">Node node</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      Node n = Reverse(node.next);</span><br><span class="line">        n.next = node;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致思路就是：传入的肯定是链表的第一个节点，那么如果这个节点还有下级节点，那么递归，直到获取到的节点是最后一个。<br>这时候，最后一个节点被返回，并且其下级节点被设置为倒数第二个，倒数第二个返回，下级被设置为倒数第三个….直到最开始的第一个节点。</p><p>当时没法调试，也不知道对不对，不过感觉差不多应该是这样了….后来(也就是今天),越想越感觉不大对…索性就自己试了一下…结果真有问题Orz…上边那个递归代码，就算成功也只能把链表最后一个节点移到第一个节点而已，其它完全还是老样子么…关键是因为没将node的下级节点置空，还会卡死…真尴尬Y(&gt;_&lt;、)Y。</p><p>真正的递归方式，应当是将当前节点的下级节点的下级设置为自己，然后将当前节点的下级节点置为空才对。这样就相当于交换了链表中两个节点的相互关系。而上边我写出的方法…相当于每次递归，都把最后一个节点向前移动了一步，其它节点的关系却毫无变化….<br>不信上图，我专门实现了一下：</p><p><img src="/blogimages/oldpictures/2017.3.5-1.png" alt="对比"></p><p>左边为成功的，右边就是上述代码造成的结果(之所以没死循环，是因为我加了最大循环次数限制的)</p><p>测试代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use this for initialization</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node();</span><br><span class="line">    node.Index = <span class="number">1</span>;</span><br><span class="line">    Node tempNode = node;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNode.next = <span class="keyword">new</span> Node();</span><br><span class="line">        tempNode.next.Index = i;</span><br><span class="line">        tempNode = tempNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PrintNode(node);</span><br><span class="line"></span><br><span class="line">    node = ReverseNode(node);</span><br><span class="line">    PrintNode(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">PrintNode</span>(<span class="params">Node node</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Log(<span class="string">&quot;___________________________________________&quot;</span>);</span><br><span class="line">    Node n = node;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">20</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Debug.Log(n.Index);</span><br><span class="line">        n = n.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (n != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">ReverseNode</span>(<span class="params">Node node</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">20</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    Node n;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = ReverseNode(node.next);</span><br><span class="line">        node.next.next = node;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">        Debug.Log(n.Index + <span class="string">&quot;  -&gt;  &quot;</span> + node.Index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> n = node;</span><br><span class="line">    <span class="comment">//面试时候手写的代码，有错</span></span><br><span class="line">    <span class="comment">//if (node.next != null)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    n = ReverseNode(node.next);</span></span><br><span class="line">    <span class="comment">//    n.next = node;</span></span><br><span class="line">    <span class="comment">//    Debug.Log(n.Index + &quot;  -&gt;  &quot; + node.Index);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else return node;</span></span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Index;</span><br><span class="line">    <span class="keyword">public</span> Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面合并有序链表的问题…..说实话，整张试卷就这题留空了…因为当时完全没注意到Date(即这儿的Index的类型)，所以还在想什么有序？加上考虑做的时间恐怕太长，就留空了…</p><p>后来，在网上找了了一下，这个面试题题目竟然都是有很多.公司用过的…网上全是相应分析…Orz…<br>看见分析，才注意到链表有序，指的是其中存储的Index有序….Σ(ﾟдﾟ；)</p><h5 id="2-解释C-中的域与程序集？-问题意思应该差不多"><a href="#2-解释C-中的域与程序集？-问题意思应该差不多" class="headerlink" title="(2)解释C#中的域与程序集？(问题意思应该差不多)"></a>(2)解释C#中的域与程序集？(问题意思应该差不多)</h5><p>当时对域的情况不是很了解，就回答了自己了解的程序集：程序集相当于包含了所有编译好的代码数据的Dll文件(记得当时…大概应该是这样回答的吧)。</p><p>下来后，查到域的解释：<br><b>应用程序域是.NET引入的一个新概念，它比进程所占用的资源要少，可以被看作是一个轻量级的进程。<br>在一个进程中可以包含多个应用程序域，一个应用程序域可以装载一个可执行程序（*.exe）或者多个程序集（*.dll）,这样可以使应用程序域之间实现深度隔离，即使进程中的某个应用程序域出现错误，也不会影响其他应用程序域的正常运作。</b></p><p>至于程序集，好像差不多。<br>权威一点解释：<br><b>程序集构成了基于 .NET 的应用程序的部署、版本控制、重用、激活范围和安全权限的基本单元。程序集以可执行 (.exe) 文件或动态链接库 (.dll) 文件的形式出现，是 .NET Framework 的生成块。它们向公共语言运行时提供了解类型实现所需要的信息。可以将程序集看成是构成逻辑功能单元并为一起工作而生成的类型和资源的集合。</b></p><h5 id="3-最后一个计算两个二维矩阵的题"><a href="#3-最后一个计算两个二维矩阵的题" class="headerlink" title="(3)最后一个计算两个二维矩阵的题"></a>(3)最后一个计算两个二维矩阵的题</h5><p>我直接将其当作了两个矩阵相乘的计算(后来想起符号是“X”，也许是矩阵叉乘)。还算错了…因为我就记得矩阵相乘是行乘列，然后就用第一行第一个数乘上右边矩阵对应列的值……最后相加。<br>最后面试的时候，第一个技术问题就是：你在学校学过线性代数么？<br>我就想到这个问题估计坏了T_T。</p><p>其它诸如农夫送狼、羊、白菜过河，C#基础题、Unity基础题应该都还好。</p><h4 id="面试-1"><a href="#面试-1" class="headerlink" title="面试"></a>面试</h4><p>最终答题完成，对面窗户外已经有点发黑了。<br>将笔试题交给前台，然后去了下厕所，并查看了下时间，记得好像差不多6点了，至少做了2个半小时吧。</p><p>又过了一会儿，一个女生走过来，带我去了更里边。一路走过….经过了许多排电脑，不少人都还在上班（毕竟才6点多），感觉好些人都在盯我…..<br>最后进入了最里面的一间会议室吧。两个面试官也走了进来，每个人手里都拿着一份我的简历，其中一个人还带着我的笔试题。</p><p>面试开始了。</p><p>首先让我做一下知我介绍，虽然经常听说面试开始时这个问题，不过自己倒是第一次被这样问。我还简单回答了一下，说了一下自己名字、老家、工作地点、目前住址之类的。</p><p>面试基本上是结合之前的项目来问的，比如说到之前我主要做AI，是怎么做的？<br>我说是使用的行为树，而且用一个叫“Behavior Designer”的插件。我主要是根据策划要求，添加相应的节点，然后策划来使用行为树配置具体的AI行为。</p><p>“然后寻路怎么做的？”<br>开始也是用的一个“A* Pathfinding Project”的插件，后来改成了Unity自带的Navmesh寻路功能。<br>“为什么要改呢？”<br>因为使用A* Pathfinding Project插件的时候，用的方格寻路，必须一直跟着玩家移动，性能消耗以及平时寻路消耗实际上都比Navmesh要大，况且策划也并没有什么高级的需要特殊定制的需求，所以就改成Unity 自带的Navmesh了。</p><p>后来问到了我之前做的Demo，说因为下载的时候太大，所以没看成…<br>然后问到如果想做一个天赋系统，该怎么实现？差不多类似于技能系统之类的。我就直接按照我实现Demo的技能系统回答，说在Actor中具有一个技能类，专门放置那些技能，外部调用XXXX.<br>后面他们解释说，我的思维模式还在单机上，手游这边的业务不是很熟啊。其实网游很多逻辑都是放在服务器上的，也就是说，比如物品系统什么的，其实是服务器程序做的…</p><p>然后问了一些问题，比如喜欢玩什么游戏？玩手游吗？</p><p>想了下，单机玩过一些上古5、辐射4、巫师3之类的，不过还是没说单机的…我就说最近、前些日子玩过一个网游《无限世界》。</p><p>他们想了一下，表示没有听说过，让我解释一下。</p><p>我就说无限世界其实是好几年前的游戏了，里面有四个职业“武侠、机甲、特种兵、法师”，将古代、现代、奇幻、科幻什么的元素糅合在了一块，创意很不错，刚出来的时候还是蛮火的，不过现在…..(估计全服务器也就几十个人顶天了…)就没落了。<br>而我之前做的Demo，其实也有不少是参考无限世界做的。(比如属性值等)</p><p>然后又说还玩过《诛仙》。<br>至于手游…就接触的少了，而且下来自己还有其它一些需要研究的，所以….</p><p>他们解释说，程序经常玩游戏还是有好处的，很多时候策划提出来的要求，都不用想，就直接明白了，甚至可以帮助策划完善其想法。</p><p>游戏优化呢？<br>我说像我之前的Demo主要就是代码的优化(对象池、字符串链接处理、尽量避免触发GC等等自己Demo都用到过….但是没能说出来…)，美术资源方面的优化就管的少了，毕竟都是Assetstore上找的，而且那些涉及到东西都比较麻烦，多数还是美术配合更好。<br>那你说说你知道的？<br>比如减少DrawCall，使用LOD..使用StaticBatch，但是这个又要求材质一样效果才好，所以又需要合并贴图啊之类的操作，所以…美术配合才好办。还有优化模型本身、合并Mesh等等。因为是面试，考虑的时间很短——基本上刚问出问题，就要开始回答，所以就大致边想边说，说了这么些。</p><p>此外林林总总就不叙述了。</p><p>快结束时，之前通知面试的女生也走了进来。</p><p>最后还问了一下工资要求，是低于期望工资就不考虑吗，还是？<br>….因为当时刚坐了长途车，想到后面换城市的话，还有搬家、各种麻烦事…所以考虑了下，回答说差不多吧，那样我想就直接在重庆找工作更方便了。</p><p>“要求的期望薪资，是家庭原因还是觉得自己能力足够？”<br>后者吧。</p><p>“你感觉自己做的笔试题怎么样嗯？”<br>想了下，除了上面那三个印象比较深可能有问题的话，其它应该还好。所以也回答说：应该还算可以吧。</p><p>后面又聊了一些其它的，就告辞了。</p><p>临走时，还问了下我怎么打算？还有面试吗？<br>我老实回答说：暂时没了，打算先找个旅馆休息一下，明天直接回去了。</p><p>她说道，面试其实可以商量下的，另外从重庆过来，也是可以提前通知，他们也好安排一下后续，比如帮忙找找旅店之类的。</p><p>我道了声谢，表示没关系。</p><p>跟她一块儿走到了出口处，道别之后，我走出了大门，准备下楼。</p><h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>下了大楼，正值下班时间，天色也有些暗淡了。<br>路上行人来来往往，相比刚过来时，竟变得有些熙熙攘攘。<br>空气中飘荡着一股凉风。不过，因为毕竟三月份了，温度已经开始上升，所以也不觉得冷了。</p><p>出门就是轻轨，我走了几步，站在了轻轨入口旁。<br>首先，查询了一下旅馆、酒店。不过收获甚小。</p><p>这时，突然收到一条短信….显示我已经使用超出流量35M…?!<br>于是赶紧关闭了网络，觉得不应该，毕竟我至少还有100多M的流量才对！在查询流量的时候，才发现套餐流量竟然是“省内”的——也就是说，一路上我都是在烧RMB…</p><p>所以决定先前往成都东站，要是没车了，就在车站那边歇一晚——毕竟一般旅馆还是车站附近最多了。<br>中途因为百度地图发疯，给我找了个需要行走2公里的“快捷路径”，导致“出站、入站”了两次，花了两倍地铁的价格才到达成都东站。<br>最后，本着不再相信车站拉客的人的想法，从阿里的未来酒店订了一个小旅馆，住了一晚。</p><p>上午起床的时候，是在8:30左右——这也是我一直设定的闹钟时间。</p><p>洗了来成都就带着的一个梨，再加上头一天晚上买的晚餐——一包烧饼，晚上也没吃多少，所以剩的挺多。解决了早餐。</p><p>本来打算立刻把票订好，不过想到附近就是火车站，所以想直接去火车站买。</p><p>9点多时，打开软件查了下列车信息….结果发现，上午的列车票竟然几乎全没了？<br>剩下的好多都是“无票”。这时候才发觉得自己的想法有点天真，现在这时代，想准点去车站买票绝对会出问题的。所以赶紧找了个10:20的D次列车，订了一个一等座——虽然稍微贵点，不过还有票的就这了…</p><p>于是在3月4日，即昨天中午的样子，回到了重庆。</p><p>记录结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这次记录的是3月3日的面试。&lt;/p&gt;
&lt;p&gt;这是也第二次技术面试——前一次的记录也写过，就是2月14号的&lt;a href=&quot;http://ww</summary>
      
    
    
    
    <category term="其它" scheme="https://cwhisme.ml/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="面试" scheme="https://cwhisme.ml/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>投影公式的推导</title>
    <link href="https://cwhisme.ml/2017/02/20/%E6%8A%95%E5%BD%B1%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/"/>
    <id>https://cwhisme.ml/2017/02/20/%E6%8A%95%E5%BD%B1%E5%85%AC%E5%BC%8F%E7%9A%84%E6%8E%A8%E5%AF%BC/</id>
    <published>2017-02-20T03:35:43.000Z</published>
    <updated>2021-01-03T03:39:40.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天偶尔看见有人说：点乘除了用于判断向量之间的相似度之外，还可用于投影的计算。</p><p>于是稍微看了下，貌似还真是！<br>通过推导投影公式，若其投影得边向量为归一化向量(在游戏中直接Normalize就好了)，那可不就是么？</p><p>然后又推导了一下投影的公式，发现竟然可以算的上是“异常”简单了！</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>首先，来看一张简单的图片吧：</p><p><img src="/blogimages/oldpictures/2017.2.20-1.png"></p><p>唔…随便用Windows的画图工具画的，看看就好，差不多就是这样了。</p><p>其中：<br>N即为底边的归一化向量，已知；<br>L为斜边，已知；<br>V为L在N上的投影向量——我们需要求出的也就是这个了。</p><p>那么，第一个很重要重要的一点是：既然N已知并且为归一化向量，那么V的模，也就是底边的长度，乘以N，是否就是V的向量了呢？<br>所以，只要能够计算出底边的长度，将底边长度乘以N向量，那么就可以得出L在N上的投影V了。</p><p>——基本原理就是这样。<br>接着，按照正常的三角形公式，把上边这个三角形的底边V的长度算出来差不多就结束了。</p><p>OK，然后，有一个大家都明白的公式：</p><p>$$<br>Cos\theta={邻边 \over 斜边}<br>$$</p><p>在这儿的表现就是：</p><p>$$<br>Cos\theta={|V| \over |L|}<br>$$</p><p>然后，转化一下下，得出：</p><p>$$<br>|V|=Cos\theta \times |L|<br>$$</p><p>此外，还有一个公式：点乘可以可以被分解成 <span>$a \cdot b=|a||b|Cos\theta$</span></p><p>所以我们可以把它代入上述公式，可得：</p><p>$$<br>|V|={Cos\theta \times |L| \times |N| \over |N|}<br>$$</p><p>简单来说，就是直接乘上了一个 <span>$|N| \over |N|$</span></p><p>这样，根据上面点乘公式，最后得出如下公式：</p><p>$$<br>|V|={L \cdot N \over |N|}<br>$$<br>因为上文我们已经说过了，是单位向量，那么|N|的值当然就是1了(就算不是，到了这儿，也没多大差别了)，既然如此，就可以化简如下：</p><p>$$<br>|V|={L \cdot N}<br>$$</p><p>哦….这样子就求出底边V的长度来了！<br>然后，按照先前提到的，长度乘以单位向量N，就得出最终公式：</p><p>$$<br>\begin{align}<br>V&amp;=|V| \times N \<br>&amp;={(L \cdot N)} \times N<br>\end{align}<br>$$</p><p>Over。<br>就是这样。</p><p>在我的游戏生涯中，其实也就曾经写V&amp;F Shader的时候，在计算高光反射向量的时候用到过（[$2N \times (L \cdot N)-L=R(反射向量)$]当然如果是直接用CG语言内置函数reflect…的话…那就算这儿也用不上了）。</p><p>原理就是这样简单。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天偶尔看见有人说：点乘除了用于判断向量之间的相似度之外，还可用于投影的计算。&lt;/p&gt;
&lt;p&gt;于是稍微看了下，貌似还真是！&lt;br&gt;通过推导投</summary>
      
    
    
    
    <category term="其它" scheme="https://cwhisme.ml/categories/%E5%85%B6%E5%AE%83/"/>
    
    
    <category term="数学" scheme="https://cwhisme.ml/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【工具】寻路算法[A*的简析与实现]</title>
    <link href="https://cwhisme.ml/2017/02/17/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <id>https://cwhisme.ml/2017/02/17/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/</id>
    <published>2017-02-17T02:47:07.000Z</published>
    <updated>2021-01-02T07:14:57.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>首先说说，为什么在这种时候突然研究这个：因为，如同前面面试那章所说，“明明感觉有印象，就是说不出个所以然来了…”，寻路算法说实话，曾经我在看《游戏人工智能编程》那本书的时候，还是专门研究过一段时间的。面试的时候虽然问的Navmesh，但是下来后我发现自己对A*的原理，也忘得差不多了…项目不用，自己也不复习的话，时间会让它变成记忆里的渣渣的！</p><p>所以，这儿必须得复习一下了！之所以名字不叫“A<em>”，是因为可能的话，我还是想先复习A</em>，然后研究下Navmesh的具体算法。<br>另外，我想把这个做成一个工具——至少以后可以随便移植使用的那种。</p><p>另外，在下的口才也不是很好，所以若有没说明白的地方…</p><p>PS:该篇文章仅代表个人理解！</p><h3 id="A-算法"><a href="#A-算法" class="headerlink" title="A*算法"></a>A*算法</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>A*算法实际上是在“Dijkstra”算法及的基础上，加入了一个“启发值”进行优化而来的。</p><p>Dijkstra算法：这个算法会在初始点向周围“辐射”，直到找到终点，其优点是一定能找到最短路径，缺点是搜索范围很大，找到终点的时候，基本上把起点到终点那一圈的距离都搜索了一遍了。</p><p>A*：在Dijkstra算法的基础上，加入了“启发值”，通常为三种：</p><h5 id="1-起点到当前点的消耗；"><a href="#1-起点到当前点的消耗；" class="headerlink" title="1.起点到当前点的消耗；"></a>1.起点到当前点的消耗；</h5><p>“起点到当前点的消耗”，一般最简单的做法是根据事先决定的每个节点的消耗，将起点至当前点路径消耗相加（若有其他需求，也可能会为不同类型的节点加入不同的消耗值。例如，若为每个区域加入不同的消耗，那么通过一堆火焰的消耗肯定就会比通过一个安全的区域要大得多，但是若通过安全区域的消耗值已经大于通过火焰的消耗，寻路就会选择通过火焰）。</p><h5 id="2-当前点到终点的消耗；"><a href="#2-当前点到终点的消耗；" class="headerlink" title="2.当前点到终点的消耗；"></a>2.当前点到终点的消耗；</h5><p>一般来说，会使用“曼哈顿距离”或者“欧几里得距离”，这个用于“启发”节点，使其总是会尽量寻找离终点最近的方向。</p><p>曼哈顿距离：计算两个节点的X、Y相减的绝对值相加——画成三角形的话，就是两条直边的和。<br>欧几里德距离：直接就是两点距离——表现为三角形的斜边长度。</p><h5 id="3-前两项之和。"><a href="#3-前两项之和。" class="headerlink" title="3.前两项之和。"></a>3.前两项之和。</h5><p>为总的消耗，该值决定了一个节点是否成为“最短路径节点”。</p><p>上述便是启发值的功能，可以看出来，启发值主要起到了一种“提示”，当然也是最重要的一点功能。若第二项启发值为0，那么就会退化成Dijkstra算法了。</p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p>效果…因为太长了，所以特意将其移到这上边来，不然都看不见了。<br>效果如下：</p><p><img src="/blogimages/oldpictures/2017.2.17-1_GIF.gif"></p><p><img src="/blogimages/oldpictures/2017.2.17-2.jpg"></p><p>咋一看还行…但是不知道是参数(启发值)还是实现问题，虽然确实总是能找到最近的一条路径，但是有时候(比如通过障碍很多等)在找这条路径的过程中，会寻找过多的无用节点(计算出路径后，显示于图中灰色的格子)——明明看起来不应该的。</p><p>后面我会再仔细分析下的，目前就到这儿了。</p><p>源码也已经放在了GitHub上(另外暂时还有写功能没实现,比如SimpleAStar的事先烘焙地图数据的保存，有空再弄吧)。</p><p>链接：<a href="https://github.com/CWHISME/SimpleAStarPathfinding">GitHub</a></p><p>——————————————————————————————————<br>后面优化调整了一下H与G值的计算比例，并且将其与地图格子大小相匹配，效果与效率都好了不少：</p><p><img src="/blogimages/oldpictures/2017.2.17-3_GIF.gif"></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>然后，来简单说一下具体原理吧。</p><p>除了上述的启发值之外，A*还会维护一个“开放表”和“关闭表”，对于已经处理过的点，会放入关闭表中，并将点周围的点放入开放表中。</p><p>主要分为以下几步：<br>1.将初始点放入开放表。<br>2.开启一个循环判断：若开放表中存在节点，取出该节点。<br>3.循环判断该节点周围的点，若该节点已经位于关闭表，跳过；<br>    若该节点为终点，结束。<br>    否则，计算消耗，并判断其是否位于开放表，若没有，将其放入开放表，否则判断其已存在于开放表中的消耗值，若消耗更小，更新消耗数据及父节点引用。然后将已计算周围节点的节点放入关闭表。<br>4.进入第二步。</p><p>(大致算法就是这么个样子了，至于清不清楚，那就得等往后我将这个算法又“再次”忘得差不多了，然后再回头看到这几句话的时候才知道了。)</p><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><p>然后，再简单地写一下伪代码吧：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">初始点,终点</span><br><span class="line"></span><br><span class="line">开放表.Add(初始点);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">当前节点=开放表[<span class="number">0</span>];</span><br><span class="line">开放表.RemoveAt(<span class="number">0</span>);</span><br><span class="line">关闭表.Add(当前节点);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(节点 <span class="keyword">in</span> 当前节点的周围节点)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(节点在关闭表中) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(节点是终点) &#123;</span><br><span class="line">节点.父节点=当前节点;</span><br><span class="line"><span class="keyword">return</span> 回溯并组成路径列表(节点);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">H=计算至终点消耗(节点,终点);</span><br><span class="line">G=当前节点.G+节点消耗;</span><br><span class="line">F=H+G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(节点在开放表中)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(G&lt;节点.G)</span><br><span class="line">&#123;</span><br><span class="line">节点.H=G;</span><br><span class="line">节点.G=G;</span><br><span class="line">节点.F=F;</span><br><span class="line">节点.父节点=当前节点;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">节点.H=G;</span><br><span class="line">节点.G=G;</span><br><span class="line">节点.F=F;</span><br><span class="line">节点.父节点=当前节点;</span><br><span class="line">开放表.Add(节点);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">根据F值排序开放列表();</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(开放表.Length&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>OK，伪码差不多这样了，接下来就是具体的实现了。</p><h5 id="Node-类"><a href="#Node-类" class="headerlink" title="Node 类"></a>Node 类</h5><p>第一步，为了方便存储节点的数据，一般来说，都要封装一个节点类。<br>在这儿，我首先创建了一个“NodeBase”:</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleAStar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Powered By  Wangjiaying</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Date: 2017.2.17</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Func :</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NodeBase</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">float</span> _x;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">float</span> _y;</span><br><span class="line">        <span class="keyword">protected</span> <span class="built_in">float</span> _z;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> X &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _x; &#125; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Y &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _y; &#125; <span class="keyword">set</span> &#123; _y = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> Z &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _z; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NodeBase</span>(<span class="params"><span class="built_in">float</span> x, <span class="built_in">float</span> y, <span class="built_in">float</span> z</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _x = x;</span><br><span class="line">            _y = y;</span><br><span class="line">            _z = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类存放了节点的X、Y、Z三个值，即具体坐标。</p><p>接下来是Node，继承于NodeBase；Node类中，保存了节点的G、H、F值以及其对于父节点的引用——这是为了最后Build路径而存在了，多数都是如此。同时还加了一个是否是障碍物的标识：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node _parentNode;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> _obstacle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _G;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _H;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _F;</span><br></pre></td></tr></table></figure><p>然后，为了方便从地图数据中取出相应节点，还将其在地图数据的索引也存储了一下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于方便从地图数据中取出的索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _indexX;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> _indexY;</span><br></pre></td></tr></table></figure><p>最后，为了方便地实现上述伪码中，根据节点的F值进行排序（以便每次都能从中取出最小的F值节点），还实现了系统的“IComparable”接口：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> IComparable&lt;Node&gt;.CompareTo(Node other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> F - other.F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node 类最终代码如下：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleAStar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Powered By  Wangjiaying</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Date: 2017.2.17</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Func :</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    [<span class="meta">System.Serializable</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span> : <span class="title">NodeBase</span>, <span class="title">IComparable</span>&lt;<span class="title">Node</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Node _parentNode;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">bool</span> _obstacle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _G;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _H;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _F;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> G &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _G; &#125; <span class="keyword">set</span> &#123; _G = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> H &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _H; &#125; <span class="keyword">set</span> &#123; _H = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> F &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _F; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于方便从地图数据中取出的索引</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _indexX;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _indexY;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> IndexX &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _indexX; &#125; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> IndexY &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _indexY; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span> IsObstacle &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _obstacle; &#125; <span class="keyword">set</span> &#123; _obstacle = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params"><span class="built_in">float</span> x, <span class="built_in">float</span> y, <span class="built_in">float</span> z</span>) : <span class="title">base</span>(<span class="params">x, y, z</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Node ParentNode &#123; <span class="keyword">set</span> &#123; _parentNode = <span class="keyword">value</span>; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Vector3 Position &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> Vector3(X, Y, Z); &#125; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetIndex</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _indexX = x;</span><br><span class="line">            _indexY = y;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RecalcF</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _F = _G + _H;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BuildPath</span>(<span class="params">List&lt;Vector3&gt; path</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            path.Add(Position);</span><br><span class="line">            <span class="keyword">if</span> (_parentNode != <span class="literal">null</span>)</span><br><span class="line">                _parentNode.BuildPath(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> IComparable&lt;Node&gt;.CompareTo(Node other)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> F - other.F;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SimpleAStar"><a href="#SimpleAStar" class="headerlink" title="SimpleAStar"></a>SimpleAStar</h5><p>SimpleAStar,这个类继承于MonoBehaviour,主要用于场景中烘焙及保存地图数据的功能。<br>初始状态下，在Awake中将自己注册至“SimpleAStarManager”中(SimpleAStarManager稍后再将，主要起一个管理作用，具体进行A*计算也是在那边)，然后…然后就没了，功能暂时来说，还是比较简单的。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleAStar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Powered By  Wangjiaying</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Date: 2017.2.17</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Func :</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleAStar</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代表该A*的区域长和宽</span></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _gridX = <span class="number">50</span>;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> _gridY = <span class="number">50</span>;</span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        <span class="comment">//格子的大小</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">float</span> _gridSize = <span class="number">1f</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> GridSize &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _gridSize; &#125; &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">SerializeField</span>]</span><br><span class="line">        [<span class="meta">HideInInspector</span>]</span><br><span class="line">        <span class="keyword">private</span> Node[,] _nodeList;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            SimpleAStarManager.GetInstance.Register(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//测试代码</span></span><br><span class="line">            <span class="comment">//因为还没做保存功能，所以开始时刷新一下</span></span><br><span class="line">            Scan();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 扫描(可以理解为烘焙一次寻路数据)</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Scan</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//初始化数组</span></span><br><span class="line">            _nodeList = <span class="keyword">new</span> Node[_gridX, _gridY];</span><br><span class="line">            <span class="comment">//起点，为当前物体的位置</span></span><br><span class="line">            <span class="built_in">float</span> x = transform.position.x;</span><br><span class="line">            <span class="built_in">float</span> y = transform.position.y;</span><br><span class="line">            <span class="built_in">float</span> z = transform.position.z;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _gridX; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; _gridY; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node node = Tools.CreateNode(<span class="keyword">new</span> Vector3(x + i * _gridSize, y, z + j * _gridSize));</span><br><span class="line">                    node.SetIndex(i, j);</span><br><span class="line">                    _nodeList[i, j] = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 获取A*地图数据</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="keyword">public</span> Node[,] MapData</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> _nodeList; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这儿只是为了显示Gizmos，所以可以不用在意</span></span><br><span class="line"><span class="comment">//不看都可以</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_nodeList == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">            Color normal = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.3f</span>);</span><br><span class="line">            Color obstacle = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.3f</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _nodeList.GetLength(<span class="number">0</span>); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; _nodeList.GetLength(<span class="number">1</span>); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Node node = _nodeList[i, j];</span><br><span class="line">                    Gizmos.color = node.IsObstacle ? obstacle : normal;</span><br><span class="line">                    Gizmos.DrawWireCube(node.Position, Vector3.one * _gridSize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Gizmos.color = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.3f</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> SimpleAStarManager.GetInstance.OpenList)</span><br><span class="line">            &#123;</span><br><span class="line">                Gizmos.DrawCube(node.Position, Vector3.one * _gridSize);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Gizmos.color = <span class="keyword">new</span> Color(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.3f</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> node <span class="keyword">in</span> SimpleAStarManager.GetInstance.CloseList)</span><br><span class="line">            &#123;</span><br><span class="line">                Gizmos.DrawCube(node.Position, Vector3.one * _gridSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要注意一下Scan方法中，对Tools的调用。</p><h5 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h5><p>该类封装了一些工具方法，目前就只有一个,即上面引用过的创建节点的方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过一个坐标点生成一个Node</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 会通过Raycast检查节点是否可一通行</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;pos&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">CreateNode</span>(<span class="params">Vector3 pos</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(pos.x, pos.y, pos.z);</span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(pos + Vector3.up * <span class="number">100</span>, Vector3.down, <span class="keyword">out</span> hit, <span class="number">120</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        node.Y = hit.point.y;</span><br><span class="line">        <span class="comment">//通过Tag来判断是否属于障碍物</span></span><br><span class="line">        <span class="keyword">if</span> (hit.transform.CompareTag(<span class="string">&quot;Obstacle&quot;</span>))</span><br><span class="line">            node.IsObstacle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法通过射线检测碰撞及障碍物，所以<font color="red">注意使用时，必须将障碍物的Tag设置为“Obstacle”才行啊</font>。</p><h5 id="SimpleAStarManager"><a href="#SimpleAStarManager" class="headerlink" title="SimpleAStarManager"></a>SimpleAStarManager</h5><p>然后是SimpleAStarManager。<br>这个类应该算是最主要和重要的一个类了。<br>上述伪代码也就主要在此实现。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleAStar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Powered By  Wangjiaying</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Date: 2017.2.17</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Func :</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleAStarManager</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> SimpleAStarManager _instance;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> SimpleAStarManager GetInstance</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (_instance == <span class="literal">null</span>) _instance = <span class="keyword">new</span> SimpleAStarManager();</span><br><span class="line">                <span class="keyword">return</span> _instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//暂时，假设一个场景只会有一个寻路数据</span></span><br><span class="line">        <span class="keyword">private</span> SimpleAStar _aStar;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Register</span>(<span class="params">SimpleAStar aStar</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            _aStar = aStar;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Node _startNode;</span><br><span class="line">        <span class="keyword">private</span> Node _endNode;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Node</span>&gt; _openList</span> = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Node</span>&gt; _closeList</span> = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">List</span>&lt;<span class="title">Vector3</span>&gt; _pathList</span> = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> UNITY_EDITOR</span></span><br><span class="line">        <span class="keyword">public</span> List&lt;Node&gt; OpenList &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _openList; &#125; &#125;</span><br><span class="line">        <span class="keyword">public</span> List&lt;Node&gt; CloseList &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> _closeList; &#125; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 计算一条从指定点到指定点的路径</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;start&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;end&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CalcPath</span>(<span class="params">Vector3 start, Vector3 end, System.Action&lt;Vector3[]&gt; callBack</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;Reuest&quot;);</span></span><br><span class="line">            <span class="comment">//计算起点位于数据图中的坐标</span></span><br><span class="line">            _startNode = GetNode(start, _aStar);</span><br><span class="line">            <span class="comment">//计算终点位于数据图中的坐标</span></span><br><span class="line">            _endNode = GetNode(end, _aStar);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.Threading.Thread thread = new System.Threading.Thread(new System.Threading.ParameterizedThreadStart(CalcPathThread));</span></span><br><span class="line">            <span class="comment">//thread.Start(callBack);</span></span><br><span class="line">            CalcPathThread(callBack);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CalcPathThread</span>(<span class="params"><span class="built_in">object</span> callback</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Debug.Log(&quot;Thread&quot;);</span></span><br><span class="line">            <span class="comment">//lock (this)</span></span><br><span class="line">            &#123;</span><br><span class="line">                _pathList.Clear();</span><br><span class="line">                _openList.Clear();</span><br><span class="line">                _closeList.Clear();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将其父级及消耗置为空，避免多次使用可能出现的问题</span></span><br><span class="line">                _startNode.ParentNode = <span class="literal">null</span>;</span><br><span class="line">                _startNode.G = <span class="number">0</span>;</span><br><span class="line">                _startNode.H = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                _openList.Add(_startNode);</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Node currentNode = _openList[<span class="number">0</span>];</span><br><span class="line">                    _openList.RemoveAt(<span class="number">0</span>);</span><br><span class="line">                    _closeList.Add(currentNode);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//计算邻边</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//目前的话，我们仅考虑四个方向</span></span><br><span class="line">                            <span class="comment">//为了简单嘛</span></span><br><span class="line">                            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                            Node node = GetNode(currentNode.IndexX + i, currentNode.IndexY + j);</span><br><span class="line">                            <span class="keyword">if</span> (node != <span class="literal">null</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="comment">//若节点就是结束点，那么...</span></span><br><span class="line">                                <span class="keyword">if</span> (node == _endNode)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    node.ParentNode = currentNode;</span><br><span class="line">                                    node.BuildPath(_pathList);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (callback != <span class="literal">null</span>)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        Vector3[] path = _pathList.ToArray();</span><br><span class="line">                                        <span class="comment">//最后将路径反向</span></span><br><span class="line">                                        System.Array.Reverse(path);</span><br><span class="line">                                        (callback <span class="keyword">as</span> System.Action&lt;Vector3[]&gt;).Invoke(path);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//已经位于关闭表，跳过</span></span><br><span class="line">                                <span class="keyword">if</span> (_closeList.Contains(node)) <span class="keyword">continue</span>;</span><br><span class="line">                                <span class="comment">//若节点是障碍物，直接放入关闭列表</span></span><br><span class="line">                                <span class="keyword">if</span> (node.IsObstacle)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    _closeList.Add(node);</span><br><span class="line">                                    <span class="keyword">continue</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//计算开始到当前节点消耗</span></span><br><span class="line">                                <span class="built_in">int</span> G = CalcG(currentNode);</span><br><span class="line">                                <span class="comment">//当前点至终点消耗</span></span><br><span class="line">                                <span class="built_in">int</span> H = CalcH(node, _endNode);</span><br><span class="line"></span><br><span class="line">                                <span class="comment">//开启表中存在节点</span></span><br><span class="line">                                <span class="keyword">if</span> (_openList.Contains(node))</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">//判断新的路径消耗</span></span><br><span class="line">                                    <span class="keyword">if</span> (G &lt; node.G)</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        node.G = G;</span><br><span class="line">                                        node.H = H;</span><br><span class="line">                                        node.ParentNode = currentNode;</span><br><span class="line">                                        node.RecalcF();</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="comment">//开启列表不存在节点</span></span><br><span class="line">                                    node.G = G;</span><br><span class="line">                                    node.H = H;</span><br><span class="line">                                    node.ParentNode = currentNode;</span><br><span class="line">                                    node.RecalcF();</span><br><span class="line">                                    <span class="comment">//添加至开启列表</span></span><br><span class="line">                                    _openList.Add(node);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//重新排序</span></span><br><span class="line">                    _openList.Sort();</span><br><span class="line">                    <span class="comment">//Debug.Log(_openList.Count);</span></span><br><span class="line">                &#125; <span class="keyword">while</span> (_openList.Count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Debug.Log(&quot;Thread End&quot;);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 通过索引获取Node，将会判断是否合法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;indexX&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;indexY&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">GetNode</span>(<span class="params"><span class="built_in">int</span> indexX, <span class="built_in">int</span> indexY</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (indexX &gt;= _aStar.MapData.GetLength(<span class="number">0</span>) || indexY &gt;= _aStar.MapData.GetLength(<span class="number">1</span>) || indexX &lt; <span class="number">0</span> || indexY &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">//Debug.Log(indexX + &quot;  &quot; + indexY);</span></span><br><span class="line">            <span class="keyword">return</span> _aStar.MapData[indexX, indexY];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalcG</span>(<span class="params">Node node</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node.G + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalcH</span>(<span class="params">Node node, Node endNode</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//使用曼哈顿距离进行Hint</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">int</span>)(Mathf.Abs(endNode.X - node.X) + Mathf.Abs(endNode.Z - node.Z));</span><br><span class="line">            <span class="comment">//return (int)Vector3.Distance(endNode.Position, node.Position);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">GetNode</span>(<span class="params">Vector3 pos, SimpleAStar aStar</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Vector3 originPos = aStar.transform.position;</span><br><span class="line">            <span class="built_in">int</span> x = (<span class="built_in">int</span>)((pos.x - originPos.x) / aStar.GridSize);</span><br><span class="line">            <span class="built_in">int</span> y = (<span class="built_in">int</span>)((pos.z - originPos.z) / aStar.GridSize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//返回计算出的点</span></span><br><span class="line">            <span class="keyword">return</span> aStar.MapData[x, y];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试脚本-SimpleAStarTest"><a href="#测试脚本-SimpleAStarTest" class="headerlink" title="测试脚本 SimpleAStarTest"></a>测试脚本 SimpleAStarTest</h5><p>最后，写了一个SimpleAStarTest的测试脚本，用于测试算法的实际功能。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleAStar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Powered By  Wangjiaying</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Date: 2017.2.17</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>   Func :</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> *******************************************</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleAStarTest</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Vector3 _startPos;</span><br><span class="line">        <span class="keyword">private</span> Vector3 _endPos;</span><br><span class="line">        <span class="keyword">private</span> Vector3[] _path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">                RaycastHit hit;</span><br><span class="line">                <span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> hit, <span class="number">100</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (_startPos == Vector3.zero)</span><br><span class="line">                    &#123;</span><br><span class="line">                        _startPos = hit.point;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    _endPos = hit.point;</span><br><span class="line">                    SimpleAStarManager.GetInstance.CalcPath(_startPos, _endPos, (path) =&gt; _path = path);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (GUILayout.Button(<span class="string">&quot;清除寻路数据&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                _startPos = Vector3.zero;</span><br><span class="line">                _endPos = Vector3.zero;</span><br><span class="line">                _path = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnDrawGizmos</span>(<span class="params"></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Gizmos.color = <span class="keyword">new</span> Color(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1f</span>);</span><br><span class="line">            <span class="keyword">if</span> (_startPos != Vector3.zero)</span><br><span class="line">                Gizmos.DrawSphere(_startPos, <span class="number">0.5f</span>);</span><br><span class="line">            Gizmos.color = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1f</span>);</span><br><span class="line">            <span class="keyword">if</span> (_endPos != Vector3.zero)</span><br><span class="line">                Gizmos.DrawSphere(_endPos, <span class="number">0.5f</span>);</span><br><span class="line">            Gizmos.color = Color.green;</span><br><span class="line">            <span class="keyword">if</span> (_path != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _path.Length - <span class="number">1</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Gizmos.DrawLine(_path[i], _path[i + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;首先说说，为什么在这种时候突然研究这个：因为，如同前面面试那章所说，“明明感觉有印象，就是说不出个所以然来了…”，寻路算法说实话，曾经我在看</summary>
      
    
    
    
    <category term="工具" scheme="https://cwhisme.ml/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/tags/Unity3D/"/>
    
  </entry>
  
  <entry>
    <title>【工具】控制台类型的作弊系统实现</title>
    <link href="https://cwhisme.ml/2017/02/14/%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E5%BC%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>https://cwhisme.ml/2017/02/14/%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E5%BC%8A%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</id>
    <published>2017-02-14T10:18:13.000Z</published>
    <updated>2021-01-02T07:14:57.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这个工具才做MagicCivilizition这个Demo的时候，很早就实现了。因为感觉“挺好玩”的，所以本来那时候就想发出来一下的，不过一推一推的，就…</p><p>游戏中，若是在Editor中的测试，貌似一般都是新加个测试脚本，然后挂上去，再弄个快捷键什么的——这样很不方便吧？特别是很多时候涉及到一些比较复杂的测试，其灵活性与专门的控制台根本没法比。而且发布之后，“测试脚本”这东西也肯定不能发出去的。</p><p>加之看到不少单机游戏，不少都具有一个专门的“控制台”。<br>所以就想到了这个，另外，为了避免被“玩家”滥用，我实现的版本特别加入了“权限”要求，并采用MD5加密，就算反编译也只能得到一串MD5码。</p><p><a href="https://github.com/CWHISME/Unity3D-CheatSystem">GitHub地址</a></p><p>如图：</p><p><img src="/blogimages/oldpictures/2017.2.14-0.jpg"></p><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>CheatSystem主要采用反射，通过搜索“CheatItem”的子类(即要求扩展的命令必须继承于“CheatItem”)，然后采用反射调用指定的方法而实现。</p><p>首先说一下权限，以及密码的设置。</p><h4 id="权限及密码"><a href="#权限及密码" class="headerlink" title="权限及密码"></a>权限及密码</h4><p>权限的定义在/Core/EnumRootLevel.cs脚本中，如下代码所示：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> EnumRootLevel</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Passward(null, <span class="meta-string">&quot;玩家&quot;</span>)</span>]</span><br><span class="line">    Player,</span><br><span class="line">    [<span class="meta">Passward(<span class="meta-string">&quot;4D3CA37D310F95E4A06AB2A503A55B87&quot;</span>, <span class="meta-string">&quot;一级&quot;</span>)</span>]</span><br><span class="line">    One,</span><br><span class="line">    [<span class="meta">Passward(<span class="meta-string">&quot;E89BBA290D125803653FC3CC5FB726AD&quot;</span>, <span class="meta-string">&quot;二级&quot;</span>)</span>]</span><br><span class="line">    Two,</span><br><span class="line">    [<span class="meta">Passward(<span class="meta-string">&quot;B47C67EB1EAE84056537D2661EDA4149&quot;</span>, <span class="meta-string">&quot;三级&quot;</span>)</span>]</span><br><span class="line">    Three,</span><br><span class="line">    [<span class="meta">Passward(<span class="meta-string">&quot;1BA7A4573ECD2668E1E63B9662560B78&quot;</span>, <span class="meta-string">&quot;管理员&quot;</span>)</span>]</span><br><span class="line">    Max,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这其中，枚举代表了权限等级，枚举之上的Passward特性，则定义了获取该权限等级的密码，以及权限的名字。<br>密码为MD5格式，可以先计算出密码的MD5，然后填写进来（这样做是为了避免被反编译获取到明文密码）。<br>默认几个权限如上代码所示，若需要新增权限，只需要按照上面的格式加进去即可。</p><h4 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h4><p>对于扩展新的功能，因为这个控制台主体是使用反射实现的，所以要求很简单：在继承于“CheatItem”类中，写下public的方法即可。<br>例如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CommandInfo(<span class="meta-string">&quot;生成一张当前屏幕所有信息截图（如控制台、UI等都会算进去）&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">CaptureScreenshot</span>(<span class="params"></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> path = GetCaptureScreenshotPath();</span><br><span class="line">    UnityEngine.Application.CaptureScreenshot(path);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;截图已保存至 &lt;color=yellow&gt;&quot;</span> + path + <span class="string">&quot;&lt;/color&gt;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，方法之上的“CommandInfo”特性是该方法的功能说明，可以在忘记功能作用时，于控制台中输入“Help XXX”获取这个帮助信息。</p><p>所有继承于“CheatItem”的类，都会被控制台所获取到，并在输入命令时执行。</p><p>另外，若想在输入类名时，直接得到结果（直接执行），那么可以参考Clear（清屏）命令，只需在类中加入方法“SingleMethod”即可.<br>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[CommandInfo(&quot;清除控制台当前所有文本信息&quot;)]</span><br><span class="line">public class Clear : CheatItem</span><br><span class="line">&#123;</span><br><span class="line">    public void SingleMethod()</span><br><span class="line">    &#123;</span><br><span class="line">        UICheatSystem.GetInstance.ClearText();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>在场景中任意物体上，挂载“CheatSystem”脚本即可。默认为按下“~”键打开，若有需要，可自行更改相应代码。</p><p>使用方法类似于系统的Console，其格式为：“类名+方法名+方法参数”</p><p>例如，输入自带的(我实现时默认扩展的通用命令)命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tools SystemInfo</span><br></pre></td></tr></table></figure><p>就能够显示如下信息：</p><p><img src="/blogimages/oldpictures/2017.2.14-1.jpg" alt="显示系统信息命令"></p><p>以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这个工具才做MagicCivilizition这个Demo的时候，很早就实现了。因为感觉“挺好玩”的，所以本来那时候就想发出来一下的，不过一</summary>
      
    
    
    
    <category term="工具" scheme="https://cwhisme.ml/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Unity3D" scheme="https://cwhisme.ml/tags/Unity3D/"/>
    
  </entry>
  
</feed>
